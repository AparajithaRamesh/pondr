---
title: "Behavioural tests"
output:
  html_notebook: 
    dev: CairoPNG
---

This notebook contains chunks of R script computing indices for five different behaviours:

- Travelled distance
- Tendency to spend time at the top of the pond
- Latency to cross an exploration box
- Tendency to hide
- Shoaling tendency

There is no behavioural test for the last index, but the metric is retrieved from the data collected for the four other tests. This notebook is so far built to compute the indices for one week of treatment, from the four weekly datasets.

## 1. Packages, data import and basic data manipulation

I first import the packages I will use in in the notebook.

```{r, results="hide", message = FALSE}

# Packages
  library(dplyr)
  library(tidyr)
  library(tibble)
  library(lubridate)
  library(ggplot2)
  library(readr)
  library(data.table)
  library(patchwork)
  library(stringr)
  library(readxl)
  library(micropan)
  library(plotly)
  library(qdapTools)
  library(arsenal)
```

I import the four dataset we get every week, one for each behavioural test. I also import the list of all the fishes, with their corresponding pond and *treatment sequence* (i.e. PP, PM, MP, MM, where P stands for 'Plus predation treatment' and M for 'Minus predation treatment'.

```{r, message = FALSE}

# Exploration box data
EB_df <- read_delim("Data/Week 1/20201102.CSV", 
     ";", escape_double = FALSE, trim_ws = TRUE)

# Bottom antennas data
bottom_df <- read_delim("Data/Week 1/20201103.CSV", 
     ";", escape_double = FALSE, trim_ws = TRUE)

# Top antennas data
#top_df <- read_delim("20201008.CSV", ";", escape_double = FALSE, trim_ws = TRUE)

# Shelters data
shelter_df <- read_delim("Data/Week 1/20201104.CSV", 
     ";", escape_double = FALSE, trim_ws = TRUE)

# List of fish
  list_fish <- read_excel("~/Cours/M2 - Sticklebacks/Data/1. Preliminary tests/4. Week -1/Ben_PITtag_final_grouped_FINAL.xlsx", 
                          sheet = "Sheet1")

```



I create the **clean.data** *function* to clean my data. This function does the following:

- It subsets a few columns of interest from the raw data (i.e. time, antenna, id)
- It keeps only one read per individual and per second for a given antenna (i.e. remove repeats)
- I assign every individual to a category named *time of the day*, indicating if it was tested during the morning or during the afternoon.
- It renames the antenna as *1, 2, 3 and 4* (see Fig 1 & Fig 2).
- It removes the ghost reads, and the reads coming from antenna tests, to only keep the fish reads in the ponds.
- It assigns each individual to its *pond number* and *treatment sequence*.

![Figure 1 - Location of the antennas for the *bottom* and the *shelter* tests.](C:/Users/benka/OneDrive/Documents/Cours/M2 - Sticklebacks/Meetings/Meeting 7 - Last practical details/Practicalities/Slide8.png)

![Figure 2 - Location of the antennas for the *top* and the *EB* tests.](C:/Users/benka/OneDrive/Documents/Cours/M2 - Sticklebacks/Meetings/Meeting 7 - Last practical details/Practicalities/Slide9.png)



```{r, message = FALSE}
clean.data <- function(df){

# Naming my columns
  names(df) <- c( "Identifier", "Date", "Time",
                  "Unit.number", "Antenna.number", "Transponder.type",
                  "Transponder.code", "Weight", "Input.status",
                  "Output.status", "Event", "GPS.coordinates")


# Defining my variables
  df$Identifier <- as.integer(df$Identifier)
  df$Time <- as.character(df$Time)
  df$Unit.number <- as.integer(df$Unit.number)
  df$Transponder.code <- as.character(df$Transponder.code)
  df$Actual_time <- dmy_hms(paste(df$Date,df$Time,sep=" "))

  
  
# I make a new df with a subset of the variables of interest here
  new_dataset<-subset(df, select=c(Actual_time, Unit.number, Transponder.code))
  names(new_dataset) <- c("time", "antenna", "id")
  new_dataset <- new_dataset  %>% distinct()
 
  
   
# I assign every individual to a group (Morning/Afternoon)
  x = as.POSIXct(strptime(c("090000","123000","190000"),"%H%M%S"),"UTC")
  date(x) <- new_dataset$time[1]

  new_dataset$time_of_day <- case_when(
    between(new_dataset$time,x[1],x[2]) ~"Morning",
    between(new_dataset$time,x[2],x[3]) ~"Afternoon")
  
  
  
# I rename my antennas with a standardised notation across ponds (see scheme above)
    new_dataset[new_dataset == 11 | new_dataset == 21 | 
                  new_dataset == 31 | new_dataset == 41] <- 1
    new_dataset[new_dataset == 12 | new_dataset == 22 | 
                  new_dataset == 32 | new_dataset == 42] <- 2
    new_dataset[new_dataset == 13 | new_dataset == 23 | 
                  new_dataset == 33 | new_dataset == 43] <- 3
    new_dataset[new_dataset == 14 | new_dataset == 24 | 
                  new_dataset == 35 | new_dataset == 34 | 
                new_dataset == 44] <- 4
    

  # Now, I will remove all the reads that do not come from the fish present 
  # in the ponds (e.g. ghost reads, test reads)
    list_fish <- read_excel("~/Cours/M2 - Sticklebacks/Data/1. Preliminary tests/4. Week -1/Ben_PITtag_final_grouped_FINAL.xlsx", 
                            sheet = "Sheet1")

# I identify the reads that do not  come from the ponds
    ghost_reads <- setdiff(new_dataset$id, list_fish$id)

# I remove all of them from the dataframe
    for (i in 1:length(ghost_reads)){
    new_dataset <- new_dataset[!(new_dataset$id == ghost_reads[i]),]
    }
    
# Now, if I run this line, I should obtain a value equal or smaller than 200.
    length(unique(new_dataset$id))    
    
# I assign every individual to its pond and treatment category
    new_dataset <- merge(new_dataset, list_fish[c(2,8,9)], by = "id")
    
  
  
  return(new_dataset)
  }

```


Next, I make a small function to obtain, for each clean data frame, the number of individuals in the pond.

```{r}

Nb.ind <- function(clean_df){
  
# I separate my data set per Pond
  ponds <- split(clean_df, f = clean_df$Pond)

# I define a vector
  ponds_df <- c()
# For each pond...
  for (i in 1:length(ponds)){
    # ... I want to obtain the number of individuals.
    ponds_df[i] <- length(unique(ponds[[i]]$id))
    
  } # end of loop

# I make a data frame with the loop output
  ponds_df <- data.frame(Pond = c(1:8), Nb = ponds_df)

    return(ponds_df)
  } # end of function

```



Then, I write another small (and very similar) function to obtain the identity of these missing individuals.

```{r}

  miss.ind <- function(clean_df){
    
 # I separate my data set per Pond
  ponds <- split(clean_df, f = clean_df$Pond)
  
  # I define a list 
  miss_ind_pond <- list()
  
  
  # For each pond...
  for (i in 1:length(ponds)){
     # I want to obtain the individuals that are in the list of fish and that were not read
     # in the pond.
     miss_ind_pond[[i]] <- setdiff(unique(subset(list_fish$id, list_fish$Pond == i)),
                                  unique(ponds[[i]]$id)
    )
  } # end of loop
  # I obtain a list, each object is a vector containing the id of the missing individuals
  # I make this list a vertical df
    miss_ind_pond <- list2df(miss_ind_pond)
  # I change the order of the columns
    miss_ind_pond <- data.frame(miss_ind_pond$X2, miss_ind_pond$X1)
  # I rename the columns
    names(miss_ind_pond) <- c("Pond", "missing_id")
  
  return(miss_ind_pond)
  }
  
```



---

## 2. Latency to explore the box
### 2.1 Data manipulation

I first clean my dataset, and look how many fish are missing and what their identity is.

```{r, message = FALSE}
  EB_clean_df <- clean.data(EB_df)
  print(EB_clean_df)  
  Nb.ind(EB_clean_df)
  
  missing_EB <- miss.ind(EB_clean_df)
  print(missing_EB)
  
  
# I split my dataframe into a list of dataframes (one object per individual)
   EB_list_df_id <- split(EB_clean_df, f = EB_clean_df$id)

```

Next, I make a data frame with the characteristics of all individuals, even the ones that haven't been read by the antennas this day. To do so, I use the Fish list imported above.

```{r, message = FALSE}
EB_variables <- merge(list_fish[,c(2, 8, 9)], 
                      unique(EB_clean_df[,c(4,5)]), by = "Pond")
length(unique(EB_variables$id))

EB_variables <- EB_variables[!duplicated(EB_variables[,c('id')]),]

```

I then define the crossing sequences and starting times.

```{r, message = FALSE}
# I indicate the crossing sequences (a -> d and d -> a)
  p1.4 = c(1, 2, 3, 4)
  p4.1 = c(4, 3, 2, 1)

# I define my starting times
  start_morning = as.POSIXct(strptime(c("093000"),"%H%M%S"),"UTC")
  date(start_morning) <- EB_clean_df$time[1]
  
  start_afternoon = as.POSIXct(strptime(c("123000"),"%H%M%S"),"UTC")
  date(start_afternoon) <- EB_clean_df$time[1]
```

---

### 2.2 Antenna changes

Next, I want to keep the reads corresponding to antenna changes. For each individual, if an invidiual has been read at the antenna the following way - 1, 1, 1, 2, 2, 3 -, we only keep the first reads for each sequence at the same antenna. The output is, for the example above: 1, 2, 3. 


```{r, message = FALSE}
  

  # I define my objects
    df_list_red <- list()
    nb_ind <- length(EB_list_df_id) # number of individuals that have been read by the antennas

    
    
  # For each individual, I want to obtain the reads corresponding to an antenna change and the
  # corresponding antenna number, time and fish id.
    for (i in 1:nb_ind) {
      EB_list_df_id[[i]] <- EB_list_df_id[[i]][order(as.POSIXct(EB_list_df_id[[i]]$time)),]
      changes          <- which(EB_list_df_id[[i]]$antenna!= lag(EB_list_df_id[[i]]$antenna))
      antenna          <- c(EB_list_df_id[[i]]$antenna[1], EB_list_df_id[[i]]$antenna[changes])
      time             <- c(EB_list_df_id[[i]]$time[1], EB_list_df_id[[i]]$time[changes])
      id               <- c(EB_list_df_id[[i]]$id[1], EB_list_df_id[[i]]$id[changes])
      df_list_red[[i]] <- data.frame(antenna, time, id)
    }


    
    
  # I bind the rows of the list (i.e. make it a dataframe, as it initially was)
    EB_Changes <- bind_rows(df_list_red)
    EB_Changes <- as.data.frame(EB_Changes)
    EB_Changes <- merge(unique(EB_clean_df[c(1,4,5,6)]), EB_Changes, by = "id", all = FALSE)

  # EB_Changes is basically the initial 'df' but the repeated reads
  # have been eliminated only to keep the first one.

    
    ```

---
    
### 2.3 Latency to cross the box
### 2.3.1 Method 1 - the elegant and intricate fashion
  

I build a function which has, as:

- Input = A data frame containing the antenna change reads for one individual
- Output = The first full cross of the exploration box, or an empty dataframe if the individual hasn't fully crossed the box.

```{r, message = FALSE}

# Packages
# Input data examples
#df <- subset(EB_Changes, id == "0007A03565") # No complete crosses
#df <- subset(EB_Changes, id == "0007A678A5") # Complete crosses
#df <- df3[[35]]




first.cross <- function(df){
  
  # I identify all the row numbers at which the individual started the sequential
  # crossing between antenna 1 and antenna 4
  rowstarts_1234  <- unlist(gregexpr("1234", paste(df$antenna, collapse="")))
  
  
  
  # If the individual has crossed the box from antenna 1 to antenna 4.
  if (rowstarts_1234[1] != -1){
  
  # Then, I subset the first full box cross (1,2,3,4)
    first_cross_1234 <- df[sort(c(outer(rowstarts_1234[1], (0:3), "+"))), ]
    first_cross_1234 <- first_cross_1234 %>% spread(antenna,time)
    first_cross_1234 <- as.data.frame(first_cross_1234)
    names(first_cross_1234) <- c("id", "time_of_day", "Pond", "Treatment_seq", 
                                 "Ant1", "Ant2", "Ant3", "Ant4")
    }
  
  
  
  # On the other hand, if the individual has crossed the box from antenna 1 to antenna 4.
  if (rowstarts_1234[1] == -1){first_cross_1234 <- 
  # Then I just obtain an empty tibble.  
    first_cross_4321 <- 
    tibble( )}
 
  
  
  # Same as above but between antenna 4 and antenna 1. 
    rowstarts_4321  <- unlist(gregexpr("4321", paste(df$antenna, collapse="")))
  if (rowstarts_4321[1] != -1){
  first_cross_4321 <- df[sort(c(outer(rowstarts_4321[1], (0:3), "+"))), ]
  first_cross_4321 <- first_cross_4321 %>% spread(antenna,time)
  first_cross_4321 <- as.data.frame(first_cross_4321)
  
  
  names(first_cross_4321) <- c("id", "time_of_day", "Pond", "Treatment_seq", 
                               "Ant1", "Ant2", "Ant3", "Ant4")}
  if (rowstarts_4321[1] == -1){first_cross_4321 <- 
    tibble( )}
  
    
  # I rbind my two tibbles.
  first_cross <- rbind(first_cross_1234, first_cross_4321)
  
  
  
  
  # If the individual did at least one full cross...
  if(dim(first_cross)[1] != 0){
  # Then, I subset its first full cross.
    first_cross <- first_cross[order(first_cross$Ant2),]
    first_cross <- first_cross[1,]}
  
  
  # On the other hand, if the individual hasn't fully crossed the box...
  if(dim(first_cross)[1] == 0){
  # Then, I just obtain a data frame with NAs.
      first_cross <- data.frame(id = df$id[1], Ant1 = NA,
                   Ant2 = NA, Ant3 = NA, Ant4 = NA)}
  
    
  return(first_cross)} # end of the function


```

Next, I can apply the function above to all individuals. I then add a column containing the latency to fully explore the box. Finally, I use the finalise.EB function to clean up the output and to obtain a plottable dataframe. 

```{r, message = FALSE}

# I split my data frame per individual
  EB_changes_list <- split(EB_Changes, f = EB_Changes$id)


# I define a list
  first_crosses <- list()

  
# For each individual...
  for(i in 1:length(EB_changes_list)){
    # I want to obtain the first full cross of the box, using the function defined above.
    first_crosses[[i]] <- first.cross(EB_changes_list[[i]])
  }
  
  
# I bind the dataframes of my list together to obtain a dataframe containing
# The first cross of all individuals that crossed the box.
  EB_Lat <- bind_rows(first_crosses)


  
# I add a new column with the time to cross the box since the start of the test
# For the morning
  EB_Lat_morning <- mutate(subset(EB_Lat, time_of_day == "Morning"), 
                           time_since_start = difftime(Ant2, start_morning, units='m'))
# For the afternoon
  EB_Lat_afternoon <- mutate(subset(EB_Lat, time_of_day == "Afternoon"), 
                             time_since_start = difftime(Ant2, start_afternoon, units='m'))

  
# I bind the two, and transform my column (in minutes) as numerical
  EB_Lat <- rbind(EB_Lat_morning, EB_Lat_afternoon)
  EB_Lat$time_since_start <- as.numeric(EB_Lat$time_since_start)

  
# I run the finalise. EB function defined above to clean my output
  EB_Lat_final <- finalise.EB(EB_Lat, EB_variables)

```

---

The histogram below shows the distribution of latencies to explore the box. All fish that did not entirely cross the box received the maximal score.

```{r, message = FALSE, dev: CairoPNG}
  
ggplot(data = EB_Lat_final, aes(time_since_start)) +
    geom_histogram(aes(),
                   bins = 6,
                   fill="#6f7b96",
                   colour = "white") +
    labs(x="Latency to explore the box (minutes)", y="Count") +
    theme(axis.ticks.x = element_blank(),
          panel.background = element_rect(fill = "#f7f5f5"))
    
    
```

The plots below show the distribution of latency scores per pond and per treatment sequence. 


```{r, message = FALSE}

    ggplot(data = EB_Lat_final, aes(x = Treatment_seq, y = time_since_start, fill = time_of_day)) + 
      geom_violin(position = position_dodge(width = 0.4)) + 
      geom_boxplot(width=.1, outlier.colour=NA, position = position_dodge(width = 0.4), colour = "black") +
      scale_fill_brewer(palette="Blues") +
      stat_summary(fun.data=mean_sdl, 
                   fun.args = list(mult = 1), # I show 1 SD
                   geom = "pointrange", color="#414c61", 
                   position = position_dodge(width = 0.4)) +
      # theme_bw() +
      theme(panel.grid.major.y = element_line(colour = "#d4d4d4"),
            panel.grid.major.x = element_blank(),
            panel.grid.minor = element_line(colour = "#e6e6e6"), 
            axis.ticks.y = element_blank(), 
            axis.ticks.x = element_blank(), 
            panel.background = element_blank(),
            axis.line.y = element_line(color = "black")) +
      labs(y = "Latency to cross the exploration box", x =" ") +
      scale_y_continuous(expand = c(0, 0), limits = c(0,NA))

windows.options(antialias = "cleartype")

    ggplot(data = EB_Lat_final, aes(x = Treatment_seq, y = time_since_start)) + 
      geom_violin(fill = "#b4d3db") + 
      stat_summary(fun.data=mean_sdl, 
                   fun.args = list(mult = 1), # I show 1 SD
                   geom = "pointrange", color="#414c61", 
                   position = position_dodge(width = 0.4)) +
      # theme_bw() +
      theme(panel.grid.major.y = element_line(colour = "#d4d4d4"),
            panel.grid.major.x = element_blank(),
            panel.grid.minor = element_line(colour = "#e6e6e6"), 
            axis.ticks.y = element_blank(), 
            axis.ticks.x = element_blank(), 
            panel.background = element_blank(),
            axis.line.y = element_line(color = "black")) +
      labs(y = "Latency to cross the exploration box", x =" ") +
      scale_y_continuous(expand = c(0, 0), limits = c(0,NA))
```





## 3. Travelled distance
### 3.1 Data manipulation and object definition


I first clean my data set, and look how many fish are missing and what their identity is. 

```{r, message = FALSE}

  bottom_clean_df <- clean.data(bottom_df)
  print(bottom_clean_df)
  Nb.ind(bottom_clean_df)
  
  missing_bottom <- miss.ind(bottom_clean_df)
  print(missing_bottom)
  
```


I make a dataframe with the characteristics of all individuals, even the ones that haven't been read by the antennas this day.

```{r, message = FALSE}
  bottom_variable <- merge(list_fish[,c(2, 8, 9)], unique(bottom_clean_df[,c(4,5)]), by = "Pond")
  
  length(unique(bottom_variable$id))
  
  bottom_variable <- bottom_variable[!duplicated(bottom_variable[,c('id')]),]

```


Then, I split it based on (i) antenna and (ii) individuals, as two lists of data frames.

```{r, message = FALSE}
# I split my dataframe into a list of dataframes (one object per individual)
    bottom_list_df_ind <- split(bottom_clean_df, f = bottom_clean_df$id)

# I split my dataframe into a list of dataframes (one object per individual)
    bottom_list_df_ant <- split(bottom_clean_df, f = bottom_clean_df$antenna)
```


I define the distances between the different antennas, and the sequence of crossing corresponding to these distances.

```{r, message = FALSE}
    # Distances between antennas
    pond.width   <- 1
    pond.length  <- 1.1
    pond.diagonal<- 1.25


    
                #######################
                #                     # 
                #        #   #        #
                #     #        #      #
                #   #  3      4   #   #
                #   #             #   #
                #   #             #   #
                #   #             #   #
                #   #  2      1   #   #
                #     #        #      #
                #       ## ##         #
                #                     #
                #    Central pond     #
                #        below        #
                #                     #
                #######################
 
    
# Sequence of antenna changes corresponding to the distances above   
    seq.width  <- c('12', '21', '34', '43')
    seq.length <- c('13', '31', '24', '42')
    seq.diag   <- c('14', '41', '23', '32')
```

---


### 3.2 Function computing the travelled distance per individual

First, I remove repeated reads at a single antenna, and obtain the antenna changes. In other words, for each individual, I reduce the sequence of reads (e.g., reads at antennas 1, 1, 1, 2, 2, 3) in a way that I only keep one read in a repeated sequence at the same antenna (e.g., reads at antennas 1, 2, 3).

Second, I compute the travelled distance between these antennas, for every change, and sum them up. At the end, I will obtain the minimal total distance that a fish has travelled between the antennas during 2:30 hours.


```{r, message = FALSE}
    trav.dist <- function(new_dataset){
    
    # I split my dataframe into a list of dataframes (one object per individual)
    df_list <- split(new_dataset, f = new_dataset$id)



##  1. REMOVE THE REPEATED READS AND OBTAIN THE ANTENNA CHANGE

    # I define 'df_list_red' which is basically 'df_list' except that the input vector
    # is replaced by the output vector.
    df_list_red <- list()
    nb_ind <- length(df_list)

    
    # I obtain the output vectors and the associated time and Identifier
    for (i in 1:nb_ind) {
      changes          <- which(df_list[[i]]$antenna!= lag(df_list[[i]]$antenna))
      antenna          <- c(df_list[[i]]$antenna[1], df_list[[i]]$antenna[changes])
      time             <- c(df_list[[i]]$time[1], df_list[[i]]$time[changes])
      id               <- c(df_list[[i]]$id[1], df_list[[i]]$id[changes])
      df_list_red[[i]] <- data.frame(antenna, time, id)
    }

    
    # I bind the rows of the list (i.e. make it a dataframe, as it initially was)
    df2 <- bind_rows(df_list_red)
    df2 <- as_tibble(df2)
    # df2 is basically the initial 'new_dataset' but the repeated reads
    # have been eliminated only to keep the first one.

    
    # I obtain the number of times each individual was read in two different antennas consecutively
    Changes <- sapply(df_list_red, nrow)
    id <- numeric() # I obtain the individual names
    for(i in 1:length(df_list_red)){
      id[i] <- df_list_red[[i]][1,3]}

    # I can generate a data frame with number of changes per individual
    df3 <- data.frame(id, Changes)


## 2. DISTANCE TRAVELLED BY EACH INDIVIDUAL

    # A for loop calculating the total distance travelled by each individuals between the antennas it's been read at
    
    # I define my Dist numerical vector
    Dist <- numeric()
    
    for (i in 1:length(df_list_red)){
      # I make three numerical vectors, each for a distance type (i.e. width/length/diagonal)
      # Each element of this vector is the number of times an individual achieved the pattern above
      # E.g. width = c(4, 2, 3, 7) corresponds to an individuals crossing 4 times 11->12, 2 times 12->11,
      # 3 times 13->14 and 7 times 14-13.
      width <- str_count(paste(df_list_red[[i]]$antenna, collapse=""), seq.width)
      length <- str_count(paste(df_list_red[[i]]$antenna, collapse=""), seq.length)
      diagonal <- str_count(paste(df_list_red[[i]]$antenna, collapse=""), seq.diag)

      
      # I obtain the achieved distance per distance type (i.e. width/length/diagonal)
      dist.width <- sum(width)*pond.width
      dist.length <- sum(length)*pond.length
      dist.diagonal <- sum(diagonal)*pond.diagonal
      
      # Total distance
      Dist[i] <- (dist.width + dist.length + dist.diagonal)
    } # end of for loop

    # Total distance travalled by all individuals
    df4 <- cbind(df3, Dist)
    
    return(df4)
    }

```


I run the function and obtain, for every individual, the distance it travelled between all the antennas it's been read at. However, some individuals might not have been read at all. Therefore, I add the individuals that, potentially, haven't been read and indicate their travelled distance as 0.

```{r, message = FALSE}
Travelled.distance <- trav.dist(bottom_clean_df)

   # I check if individuals might have not been recorded at all by the antennas
    non_read_babies <- setdiff(list_fish$id, Travelled.distance$id)
    non_read_babies <- data.frame(id = non_read_babies, Changes =  0, Dist =  0)
    
    # Final df containing the read (and potential non-read) individuals
    Travelled.distance <- rbind(Travelled.distance, non_read_babies)
```




---

### 3.3 Plotting

First, I will, for every individual, indicate to what pond and treatment it is associated with.

```{r, message = FALSE}
    

# I assign every individual to its pond and treatment category
    Travelled.distance <- merge(bottom_variable, Travelled.distance, by = "id", all = T)


```


I first do violin plots (with mean and SD) showing all tratment sequences and the time of the day


```{r, message = FALSE}
  # Violin plots for differences between the 8 ponds within a week
      ggplot(data = Travelled.distance, aes(x = Treatment_seq, y = Dist, fill = time_of_day)) + 
      geom_violin(position = position_dodge(width = 0.4)) + 
      
      geom_boxplot(width=.1, outlier.colour=NA, 
                   position = position_dodge(width = 0.4), colour = "black") +
      
      scale_fill_brewer(palette="Blues") +
      
      stat_summary(fun.data=mean_sdl, 
                   fun.args = list(mult = 1), # I show 1 SD
                   geom = "pointrange", color="#414c61", 
                   position = position_dodge(width = 0.4)) +
      # theme_bw() +
      theme(panel.grid.major.y = element_line(colour = "#d4d4d4"),
            panel.grid.major.x = element_blank(),
            panel.grid.minor = element_line(colour = "#e6e6e6"), 
            axis.ticks.y = element_blank(), 
            axis.ticks.x = element_blank(), 
            panel.background = element_blank(),
            axis.line.y = element_line(color = "black")) +
      labs(y = "Travelled distance (meters)", x =" ") +
      scale_y_continuous(expand = c(0, 0), limits = c(0,NA))


    ggplot(data = Travelled.distance, aes(x = Treatment_seq, y = Dist)) + 
      geom_violin(fill = "#b4d3db") + 
      stat_summary(fun.data=mean_sdl, 
                   fun.args = list(mult = 1), # I show 1 SD
                   geom = "pointrange", color="#414c61", 
                   position = position_dodge(width = 0.4)) +
      # theme_bw() +
      theme(panel.grid.major.y = element_line(colour = "#d4d4d4"),
            panel.grid.major.x = element_blank(),
            panel.grid.minor = element_line(colour = "#e6e6e6"), 
            axis.ticks.y = element_blank(), 
            axis.ticks.x = element_blank(), 
            panel.background = element_blank(),
            axis.line.y = element_line(color = "black")) +
      labs(y = "Travelled distance (meters)", x =" ") +
      scale_y_continuous(expand = c(0, 0), limits = c(0,NA))
```

Below, I will also make a Raincloud plot to see how these scores change over time. No more distinction is made here between the two replicates (morning/afternoon) for visibility reasons.

I first import a few additional packages

```{r, message = FALSE}
    library(caTools)
    library(bitops)
    library(cowplot)
    library(dplyr)
    library(readr)
    library(grid)
```

I change my working directory to have access to the R files from this GitHub repository: https://github.com/RainCloudPlots/RainCloudPlots/tree/master/tutorial_R. 

```{r, message = FALSE}
  # Set working directory
    setwd("/Users/benka/OneDrive/Documents/GitHub/RainCloudPlots/tutorial_R")


    source("R_rainclouds.R")
    source("summarySE.R")
    source("simulateData.R")
```

```{r, message = FALSE}
 
    # This is fake data
    Travelled.distance2 <- rbind(Travelled.distance, Travelled.distance, Travelled.distance)
    Travelled.distance2$Dist <- c(Travelled.distance$Dist, Travelled.distance$Dist/2, Travelled.distance$Dist/3)
    Travelled.distance2$time <- c(rep(c("W1"), times = 100), rep(c("W2"), times = 100), rep(c("W3"), times = 100))
    

    # Summary statistics
    sumrepdat <- summarySE(Travelled.distance2, measurevar = "Dist", groupvars=c("Treatment_seq", "time"))    
    
    # General information about the plot
    ggplot(Travelled.distance2, aes(x = time, y = Dist, fill = Treatment_seq)) + 
      
      # Layer 1 - The half-violins to show densities
      geom_flat_violin(aes(fill = Treatment_seq), 
                       position = position_nudge(x = .1, y = 0), 
                       adjust = 2, trim = FALSE, alpha = .6, 
                       colour = NA) + 
      
      # Layer 2 - All the individual data points
      geom_point(aes(x = time,
                     group = id,
                     y = Dist, 
                     colour = Treatment_seq), 
                     position = position_dodge(width = .1), 
                     size = 1, shape = 19, alpha = 0.4) + 
      
      # Layer 3 - These individual data points are linked together by thin lines
      geom_line(aes(group = id
                ,colour = Treatment_seq
                ), linetype = 1,
                alpha = 0.1, size = 0.5, 
                #colour = "gray",
                position = position_dodge(width = .1)) +


      

      # Layer 5 - A line linking these means
      geom_line(data = sumrepdat, aes(y =  Dist_mean, group = Treatment_seq, 
                                      colour = Treatment_seq), linetype = 1, size = 1) +
      
      # Layer 6 - A mean per treatment sequence
      geom_point(data = sumrepdat, aes(y =  Dist_mean, group = Treatment_seq, 
                                       colour = Treatment_seq), shape = 19, size = 2) +
 
      # Layer 6' - SE/SD bars
      #geom_errorbar(data = sumrepdat, aes( 
      #  y =  Dist_mean, group = Treatment_seq, 
      #  colour = Treatment_seq, ymin =  Dist_mean-sd, 
      #  ymax =  Dist_mean+se), width = 0.05, size = 1.2) +
      
      
      # Define the colours 
      scale_colour_manual(values=c("#eb676e", "#f7bd6a", "#6e67b5", "#b3d6e6")) + 
      scale_fill_manual(values=c("#eb676e", "#f7bd6a", "#6e67b5", "#b3d6e6"))+
      
      # Define the theme
      theme_cowplot()

```


## 4. Tendency to hide
### 4.1 Data manipulation

I first clean my data and check who's missing.

```{r, message = FALSE}
  Shelter_clean_df <- clean.data(shelter_df)
  print(Shelter_clean_df)
  Nb.ind(Shelter_clean_df)
  
  missing_shelter <- miss.ind(Shelter_clean_df)
  print(missing_shelter)
  
# I split my dataframe into a list of dataframes (one object per individual)
   Shelter_list_df_id <- split(Shelter_clean_df, f = Shelter_clean_df$id)

   
```

### 4.2 Duration spent at each antenna

Next, I make a dataframe with the characteristics of all individuals, even the ones that haven't been read by the antennas this day. To do so, I use the Fish list imported above.

```{r, message = FALSE}
Shelter_variables <- merge(list_fish[,c(2, 8, 9)], 
                      unique(Shelter_clean_df[,c(4,5)]), by = "Pond")


Shelter_variables <- Shelter_variables[!duplicated(Shelter_variables[,c('id')]),]

```


```{r, message = FALSE}

nreads <- c()
ids <- character()
for (i in 1:length(Shelter_list_df_id)){
ids[i] <- Shelter_list_df_id[[i]]$id[1]
nreads[i] <- nrow(Shelter_list_df_id[[i]])}

Shelter_nreads <- data.frame(id = ids, nb = nreads)


```

### 4.3 Plotting

First, I will, for every individual, indicate to what pond and treatment it is associated with.

```{r, message = FALSE}
    

# I assign every individual to its pond and treatment category
    Shelter_nreads <- merge(Shelter_variables, Shelter_nreads, by = "id", all = T)


```


```{r}
hist(Shelter_nreads$nb/60)
```



```{r message=FALSE}
  # Violin plots for differences between the 8 ponds within a week
      ggplot(data = Shelter_nreads, aes(x = Treatment_seq, y = nb/60, fill = time_of_day)) + 
      geom_violin(position = position_dodge(width = 0.4)) + 
      
      #geom_boxplot(width=.1, outlier.colour=NA, 
      #             position = position_dodge(width = 0.4), colour = "black") +
      
      scale_fill_brewer(palette="Blues") +
      
      stat_summary(fun.data=mean_sdl, 
                   fun.args = list(mult = 1), # I show 1 SD
                   geom = "pointrange", color="#414c61", 
                   position = position_dodge(width = 0.4)) +
      # theme_bw() +
      theme(panel.grid.major.y = element_line(colour = "#d4d4d4"),
            panel.grid.major.x = element_blank(),
            panel.grid.minor = element_line(colour = "#e6e6e6"), 
            axis.ticks.y = element_blank(), 
            axis.ticks.x = element_blank(), 
            panel.background = element_blank(),
            axis.line.y = element_line(color = "black")) +
      labs(y = "Travelled distance (meters)", x =" ") +
      scale_y_continuous(expand = c(0, 0), limits = c(0,NA))


    ggplot(data = Shelter_nreads, aes(x = Treatment_seq, y = nb/60)) + 
      geom_violin(fill = "#b4d3db") + 
      stat_summary(fun.data=mean_sdl, 
                   fun.args = list(mult = 1), # I show 1 SD
                   geom = "pointrange", color="#414c61", 
                   position = position_dodge(width = 0.4)) +
      # theme_bw() +
      theme(panel.grid.major.y = element_line(colour = "#d4d4d4"),
            panel.grid.major.x = element_blank(),
            panel.grid.minor = element_line(colour = "#e6e6e6"), 
            axis.ticks.y = element_blank(), 
            axis.ticks.x = element_blank(), 
            panel.background = element_blank(),
            axis.line.y = element_line(color = "black")) +
      labs(y = "Time spent hiding (minutes)", x =" ") +
      scale_y_continuous(expand = c(0, 0), limits = c(0,NA))
```

## 5. Time spent at the top of the water column


```{r, message = FALSE}

```

```{r, message = FALSE}

```

```{r, message = FALSE}

```


## 6. Summary of the week

I can first look at the individuals that were never read during the whole week. These individuals potentially died, or lost their tag.


```{r, message = FALSE}
missing_ind_df <- Reduce(intersect, list(missing_EB,
                       missing_bottom,
                       missing_shelter))
print(missing_ind_df)
```

```{r, message = FALSE}

```

