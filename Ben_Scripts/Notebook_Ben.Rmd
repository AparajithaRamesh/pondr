---
title: "Behavioural tests"
output: html_notebook
---

This notebook contains chunks computing indiced for a set of behaviours:

- Travelled distance
- Tendency to spend time at the top of the pond
- Latency to cross an exploration box
- Tendency to hide
- Shoaling tendency
There is no behavioural test for the latter behavioural index, but the metric is retrieved from the data of the other tests.

## 1. Packages, data import and basic data manipulation


```{r, results="hide", message = FALSE}
# Packages
  library(dplyr)
  library(tidyr)
  library(tibble)
  library(lubridate)
  library(ggplot2)
  library(readr)
  library(data.table)
  library(patchwork)
  library(stringr)
  library(readxl)
  library(micropan)
  library(plotly)
```

I import the four dataset we get every week, one for each behavioural test. I also import the list of all the fishes.

```{r, message = FALSE}

# Data import
df_EB <- read_delim("Data/Week 1/20201102.CSV", 
     ";", escape_double = FALSE, trim_ws = TRUE)

df_bottom <- read_delim("Data/Week 1/20201103.CSV", 
     ";", escape_double = FALSE, trim_ws = TRUE)

#df_top <- read_delim("20201008.CSV", ";", escape_double = FALSE, trim_ws = TRUE)

#df_shelter <- read_delim("20201008.CSV", ";", escape_double = FALSE, trim_ws = TRUE)
list_fish <- read_excel("~/Cours/M2 - Sticklebacks/Data/1. Preliminary tests/4. Week -1/Ben_PITtag_final_grouped_FINAL.xlsx", 
                        sheet = "Sheet1")

```



I create the **clean.data** *function* to clean my data. This function does the following:

- It subsets a few columns of interest from the raw data (i.e. time, antenna, id)
- It keeps only one read per individual and per second for a given antenna (i.e. remove repeats)
- I assign every individual to a category named *time of the day*, indicating if it was tested during the morning or during the afternoon.
- I rename the antenna as *1, 2, 3 and 4* (see Fig 1 & Fig 2).
- I remove the ghost reads, and the reads coming from antenna tests, to only keep the fish reads in the ponds.
- I assign each individual to its *pond number* and *treatment sequence*.

![Figure 1](C:/Users/benka/OneDrive/Documents/Cours/M2 - Sticklebacks/Meetings/Meeting 7 - Last practical details/Practicalities/Slide8.png)

![Figure 2](C:/Users/benka/OneDrive/Documents/Cours/M2 - Sticklebacks/Meetings/Meeting 7 - Last practical details/Practicalities/Slide9.png)

```{r, message = FALSE}
clean.data <- function(df){

# Naming my columns
  names(df) <- c( "Identifier", "Date", "Time",
                  "Unit.number", "Antenna.number", "Transponder.type",
                  "Transponder.code", "Weight", "Input.status",
                  "Output.status", "Event", "GPS.coordinates")


# Defining my variables
  df$Identifier <- as.integer(df$Identifier)
  df$Time <- as.character(df$Time)
  df$Unit.number <- as.integer(df$Unit.number)
  df$Transponder.code <- as.character(df$Transponder.code)
  df$Actual_time <- dmy_hms(paste(df$Date,df$Time,sep=" "))

  
  
# I make a new df with a subset of the variables of interest here
  new_dataset<-subset(df, select=c(Actual_time, Unit.number, Transponder.code))
  names(new_dataset) <- c("time", "antenna", "id")
  new_dataset <- new_dataset  %>% distinct()
 
  
   
# I assign every individual to a group (Morning/Afternoon)
  x = as.POSIXct(strptime(c("090000","123000","190000"),"%H%M%S"),"UTC")
  date(x) <- new_dataset$time[1]

  new_dataset$time_of_day <- case_when(
    between(new_dataset$time,x[1],x[2]) ~"Morning",
    between(new_dataset$time,x[2],x[3]) ~"Afternoon")
  
  
  
# I rename my antennas with a standardised notation across ponds (see scheme above)
    new_dataset[new_dataset == 11 | new_dataset == 21 | new_dataset == 31 | new_dataset == 41] <- 1
    new_dataset[new_dataset == 12 | new_dataset == 22 | new_dataset == 32 | new_dataset == 42] <- 2
    new_dataset[new_dataset == 13 | new_dataset == 23 | new_dataset == 33 | new_dataset == 43] <- 3
    new_dataset[new_dataset == 14 | new_dataset == 24 | new_dataset == 35 | new_dataset == 34 | 
                new_dataset == 44] <- 4
    

  # Now, I will remove all the reads that do not come from the fish present in the ponds (e.g. ghost reads, test reads)
    list_fish <- read_excel("~/Cours/M2 - Sticklebacks/Data/1. Preliminary tests/4. Week -1/Ben_PITtag_final_grouped_FINAL.xlsx", 
                            sheet = "Sheet1")

# I identify the reads that do not  come from the ponds
    ghost_reads <- setdiff(new_dataset$id, list_fish$id)

# I remove all of them from the dataframe
    for (i in 1:length(ghost_reads)){
    new_dataset <- new_dataset[!(new_dataset$id == ghost_reads[i]),]
    }
    
# Now, if I run this line, I should obtain a value equal or smaller than 200.
    length(unique(new_dataset$id))    
    
# I assign every individual to its pond and treatment category
    new_dataset <- merge(new_dataset, list_fish[c(2,8,9)], by = "id")
    
  
  
  return(new_dataset)
  }

```


---

## 2. Latency to explore the box
### 2.1 Data manipulation

I first run the **clean.data** function on the EB data frame, then split it per individual.

```{r, message = FALSE}
  EB_clean_df <- clean.data(df_EB)
  
# I split my dataframe into a list of dataframes (one object per individual)
   EB_list_df_id <- split(EB_clean_df, f = EB_clean_df$id)

```

Next, I make a dataframe with the characteristics of all individuals, even the ones that haven't been read by the antennas this day.

```{r, message = FALSE}
EB_variables <- merge(list_fish[,c(2, 8, 9)], unique(EB_clean_df[,c(4,5)]), by = "Pond")
length(unique(EB_variables$id))

EB_variables <- EB_variables[!duplicated(EB_variables[,c('id')]),]

```

I then define the crossing sequences and starting times.

```{r, message = FALSE}
# I indicate the crossing sequences (a -> d and d -> a)
  p1.4 = c(1, 2, 3, 4)
  p4.1 = c(4, 3, 2, 1)

# I define my starting times
  start_morning = as.POSIXct(strptime(c("093000"),"%H%M%S"),"UTC")
  date(start_morning) <- EB_clean_df$time[1]
  
  start_afternoon = as.POSIXct(strptime(c("123000"),"%H%M%S"),"UTC")
  date(start_afternoon) <- EB_clean_df$time[1]
```

---

### 2.2 Antenna changes

Next, I want to keep the reads corresponding to antenna changes. For each individual, if an invidiual has been read at the antenna the following way - 1, 1, 1, 2, 2, 3 -, we only keep the first reads for each sequence at the same antenna. The output is, for the example above: 1, 2, 3. 



```{r, message = FALSE}
  

  # I define my objects
    df_list_red <- list()
    nb_ind <- length(EB_list_df_id) # number of individuals that have been read by the antennas

  # I obtain the output vectors and the associated time
    for (i in 1:nb_ind) {
      EB_list_df_id[[i]] <- EB_list_df_id[[i]][order(as.POSIXct(EB_list_df_id[[i]]$time)),]
      changes          <- which(EB_list_df_id[[i]]$antenna!= lag(EB_list_df_id[[i]]$antenna))
      antenna          <- c(EB_list_df_id[[i]]$antenna[1], EB_list_df_id[[i]]$antenna[changes])
      time             <- c(EB_list_df_id[[i]]$time[1], EB_list_df_id[[i]]$time[changes])
      id               <- c(EB_list_df_id[[i]]$id[1], EB_list_df_id[[i]]$id[changes])
      df_list_red[[i]] <- data.frame(antenna, time, id)
    }


  # I bind the rows of the list (i.e. make it a dataframe, as it initially was)
    EB_Changes <- bind_rows(df_list_red)
    EB_Changes <- as.data.frame(EB_Changes)
    EB_Changes <- merge(unique(EB_clean_df[c(1,4,5,6)]), EB_Changes, by = "id", all = FALSE)

  # EB_Changes is basically the initial 'df' but the repeated reads
  # have been eliminated only to keep the first one.

    
    ```

---
    
### 2.3 Latency to cross the box
### 2.3.1 Method 1 - the elegant and intricate fashion
  
Next, I want to obtain the latency between the time the box was introduced into the pond and the moment each individual fully explored it. I create the *lat.expl* function, which has, as an:

- Inout: The reads corresponding to antenna changes for all individuals (data frame). Details in the chunk just above.
- Output: The first box cross for all individuals (data frame). A column is also computing how long since the box has been introduced the individuals have taken to enter the box.
    
    
    ```{r, message = FALSE}
    
    
# 1. I create the 'lat.expl' function for 'Latency to explore'.
    # From the cleaned data frame, it outputs all the individual full crossings.
    lat.expl <- function(df, pattern1, pattern2, initial_time){
    
  ## 2. IDENTIFY WHEN INDIVIDUALS CROSS THE BOX ENTIRELY
  # I stole the next piece of code from someone way smarter than me (see R Stack Overflow 41130912).
  # First, I keep reads when individuals go through the box the following way: 1 -> 2 -> 3 -> 4
    len_pattern = 4
    df_abcd <- df %>% arrange(id, time) %>% group_by(id) %>%
    # check multiple lags condition
    mutate(ab = Reduce("&", Map("==", shift(antenna, n = 0:(len_pattern - 1), type = "lead"), pattern1)),
    g = cumsum(ab)) %>%
    # use reduce or to subset sequence rows having the same length as the pattern
    filter(Reduce("|", shift(ab, n = 0:(len_pattern - 1), type = "lag"))) %>%
    # make unique names
    group_by(g, add = TRUE) %>% mutate(antenna = paste(antenna, 1:n(), sep = "_")) %>%
    # pivoting the table to wide format
    select(-ab) %>% spread(antenna, time)



  # Second, I keep reads when individuals go through the box the other way around: 4 -> 3 -> 2 -> 1
    df_dcba <- df %>% arrange(id, time) %>% group_by(id) %>%
    # check multiple lags condition
    mutate(ab = Reduce("&", Map("==", shift(antenna, n = 0:(len_pattern - 1), type = "lead"), pattern2)),
    g = cumsum(ab)) %>%
    # use reduce or to subset sequence rows having the same length as the pattern
    filter(Reduce("|", shift(ab, n = 0:(len_pattern - 1), type = "lag"))) %>%
    # make unique names
    group_by(g, add = TRUE) %>% mutate(antenna = paste(antenna, 1:n(), sep = "_")) %>%
    # pivoting the table to wide format
    select(-ab) %>% spread(antenna, time)


  # I rename the columns of the two dataframes I created
  names(df_abcd) <- c("id", "time_of_day", "Pond", "Treatment_seq", "g", "Ant1", "Ant2", "Ant3", "Ant4")
  names(df_dcba) <- c("id", "time_of_day", "Pond", "Treatment_seq", "g", "Ant1", "Ant2", "Ant3", "Ant4")

  # I obtain a dataframe in which each row represents one individual full crossing
  df3 <- rbind(df_abcd, df_dcba)

  # I keep individuals with the smallest 'arrival' (i.e. Ant2) value.
  df3 <- df3 %>%
    group_by(id) %>%
    slice(which.min(Ant2))




  ## 3. CALCULATE LATENCY TIME
  # I add a new column with the time to cross the box since the start of the test
  df3 <- mutate(df3, time_since_start = difftime(Ant2, initial_time, units='mins'))
  df3$time_since_start <- as.numeric(df3$time_since_start)




  return(df3)
}

```


I run my function.

```{r}
# I run my functions for the morning and the afternoon
  EB_Lat_Morning <- lat.expl(subset(EB_Changes, time_of_day == "Morning"), p1.4, p4.1, start_morning)
  EB_Lat_Afternoon <- lat.expl(subset(EB_Changes, time_of_day == "Afternoon"), p1.4, p4.1, start_afternoon)

# I obtain my final dataset with the first crossing sequence for every individual and at what time it happened
  EB_Lat <- rbind(EB_Lat_Morning, EB_Lat_Afternoon)
  
  EB_Lat_final <- merge(EB_Lat[c(1,6:10)], EB_variables[c('id', "time_of_day", "Pond", "Treatment_seq")], by = 'id', all = T)

  
  EB_Lat_final$time_since_start[is.na(EB_Lat_final$time_since_start)] <- 150
  EB_Lat_final$Expl_index <-  abs(c(EB_Lat_final$time_since_start - 150))
  EB_Lat_final <- EB_Lat_final[c("id", "Pond", "Treatment_seq", "time_since_start", "time_of_day", "Expl_index")]
  
```

---

### 2.3.2 Method 2 - the long but understandible fashion

Here is an alternative version of the chunk above. It is less elegant, yet (a lot?) more understandible.
First, I build a function which has, as:

- Inout = Dataframe containing the antenna changes for one individual
- Output = The first full cross of the exploration box, or an empty dataframe if the individual hasn't fully crossed the box.

```{r, message = FALSE}

# Packages
# Input data examples
#df <- subset(EB_Changes, id == "0007A03565") # No complete crosses
#df <- subset(EB_Changes, id == "0007A678A5") # Complete crosses
#df <- df3[[35]]




first.cross <- function(df){
  
  # I identify all the row numbers at which the individual started the sequential
  # crossing between antenna 1 and antenna 4
  rowstarts_1234  <- unlist(gregexpr("1234", paste(df$antenna, collapse="")))
  
  # If the individual has crossed the box from antenna 1 to antenna 4.
  if (rowstarts_1234[1] != -1){
  
  # Then, I subset the first full box cross (1,2,3,4)
    first_cross_1234 <- df[sort(c(outer(rowstarts_1234[1], (0:3), "+"))), ]
    first_cross_1234 <- first_cross_1234 %>% spread(antenna,time)
    first_cross_1234 <- as.data.frame(first_cross_1234)
    names(first_cross_1234) <- c("id", "time_of_day", "Pond", "Treatment_seq", "Ant1", "Ant2", "Ant3", "Ant4")
    }
  
  # On the other hand, if the individual has crossed the box from antenna 1 to antenna 4.
  if (rowstarts_1234[1] == -1){first_cross_1234 <- 
  # Then I just obtain an empty tibble.  
    first_cross_4321 <- 
    tibble( )}
 
  # Same as above but between antenna 4 and antenna 1. 
    rowstarts_4321  <- unlist(gregexpr("4321", paste(df$antenna, collapse="")))
  if (rowstarts_4321[1] != -1){
  first_cross_4321 <- df[sort(c(outer(rowstarts_4321[1], (0:3), "+"))), ]
  first_cross_4321 <- first_cross_4321 %>% spread(antenna,time)
  first_cross_4321 <- as.data.frame(first_cross_4321)
  names(first_cross_4321) <- c("id", "time_of_day", "Pond", "Treatment_seq", "Ant1", "Ant2", "Ant3", "Ant4")}
  if (rowstarts_4321[1] == -1){first_cross_4321 <- 
    tibble( )}
  
  # I rbind my two tibbles.
  first_cross <- rbind(first_cross_1234, first_cross_4321)
  
  
  # If the individual did at least one full cross...
  if(dim(first_cross)[1] != 0){
  # Then, I subset its first full cross.
    first_cross <- first_cross[order(first_cross$Ant2),]
    first_cross <- first_cross[1,]}
  
  # On the other hand, if the individual hasn't fully crossed the box...
  if(dim(first_cross)[1] == 0){
  # Then, I just obtain a data frame with NAs.
      first_cross <- data.frame(id = df$id[1], Ant1 = NA,
                   Ant2 = NA, Ant3 = NA, Ant4 = NA)}
  
    
  return(first_cross)} # end of the function


```



```{r, message = FALSE}

EB_changes_list <- split(EB_Changes, f = EB_Changes$id)

first_crosses <- list()
for(i in 1:length(EB_changes_list)){
  
  first_crosses[[i]] <- first.cross(EB_changes_list[[i]])
}
EB_Lat_2 <- bind_rows(first_crosses)


# I add a new column with the time to cross the box since the start of the test
EB_Lat_2_morning <- mutate(subset(df3, time_of_day == "Morning"), time_since_start = difftime(Ant2, start_morning, units='m'))
EB_Lat_2_afternoon <- mutate(subset(df3, time_of_day == "Afternoon"), time_since_start = difftime(Ant2, start_afternoon, units='m'))
EB_Lat_2 <- rbind(EB_Lat_2_morning, EB_Lat_2_afternoon)
EB_Lat_2$time_since_start <- as.numeric(EB_Lat_2$time_since_start)

# I remove the rows with NAs (i.e. individuals that did not cross the box entirely)
EB_Lat_2 <- na.omit(EB_Lat_2)
```


```{r, message = FALSE}
  ggplot(data=EB_Lat_final, aes(Expl_index)) +
    geom_histogram(aes(),
                   bins = 6,
                   fill="#6f7b96",
                   colour = "white") +
    labs(x="Latency to explore the box (minutes)", y="Count") +
    theme(axis.ticks.x = element_blank(),
          panel.background = element_rect(fill = "#f7f5f5"))
```



```{r, message = FALSE}

    ggplot(data = EB_Lat_final, aes(x = Treatment_seq, y = time_since_start, fill = time_of_day)) + 
      geom_violin(position = position_dodge(width = 0.4)) + 
      #geom_boxplot(width=.1, outlier.colour=NA, position = position_dodge(width = 0.4), colour = "black") +
      scale_fill_brewer(palette="Blues") +
      stat_summary(fun.data=mean_sdl, 
                   fun.args = list(mult = 1), # I show 1 SD
                   geom = "pointrange", color="#414c61", 
                   position = position_dodge(width = 0.4)) +
      # theme_bw() +
      theme(panel.grid.major.y = element_line(colour = "#d4d4d4"),
            panel.grid.major.x = element_blank(),
            panel.grid.minor = element_line(colour = "#e6e6e6"), 
            axis.ticks.y = element_blank(), 
            axis.ticks.x = element_blank(), 
            panel.background = element_blank(),
            axis.line.y = element_line(color = "black")) +
      labs(y = "Latency to cross the exploration box", x =" ") +
      scale_y_continuous(expand = c(0, 0), limits = c(0,NA))



    ggplot(data = EB_Lat_final, aes(x = Treatment_seq, y = time_since_start)) + 
      geom_violin(fill = "#b4d3db") + 
      stat_summary(fun.data=mean_sdl, 
                   fun.args = list(mult = 1), # I show 1 SD
                   geom = "pointrange", color="#414c61", 
                   position = position_dodge(width = 0.4)) +
      # theme_bw() +
      theme(panel.grid.major.y = element_line(colour = "#d4d4d4"),
            panel.grid.major.x = element_blank(),
            panel.grid.minor = element_line(colour = "#e6e6e6"), 
            axis.ticks.y = element_blank(), 
            axis.ticks.x = element_blank(), 
            panel.background = element_blank(),
            axis.line.y = element_line(color = "black")) +
      labs(y = "Latency to cross the exploration box", x =" ") +
      scale_y_continuous(expand = c(0, 0), limits = c(0,NA))
```


```{r, message = FALSE}

```



## 3. Travelled distance
### 3.1 Data manipulation and object definition


I first run the **clean.data** function on the bottom antenna data frame. 

```{r, message = FALSE}
bottom_clean_df <- clean.data(df_bottom)
print(bottom_clean_df)
length(unique(bottom_clean_df$id))
```


I make a dataframe with the characteristics of all individuals, even the ones that haven't been read by the antennas this day.
```{r, message = FALSE}
bottom_variable <- merge(list_fish[,c(2, 8, 9)], unique(bottom_clean_df[,c(4,5)]), by = "Pond")
length(unique(bottom_variable$id))

bottom_variable <- bottom_variable[!duplicated(bottom_variable[,c('id')]),]

```


Then, I split it based on (i) antenna and (ii) individuals, as two list of data frames.

```{r, message = FALSE}
# I split my dataframe into a list of dataframes (one object per individual)
    bottom_list_df_ind <- split(bottom_clean_df, f = bottom_clean_df$id)

# I split my dataframe into a list of dataframes (one object per individual)
    bottom_list_df_ant <- split(bottom_clean_df, f = bottom_clean_df$antenna)
```


I define the distances between the different antennas, and the sequence of crossing corresponding to these distances.

```{r, message = FALSE}
    # Distances between antennas
    pond.width   <- 1
    pond.length  <- 1.1
    pond.diagonal<- 1.25


    
                #######################
                #                     # 
                #        #   #        #
                #     #        #      #
                #   #  3      4   #   #
                #   #             #   #
                #   #             #   #
                #   #             #   #
                #   #  2      1   #   #
                #     #        #      #
                #       ## ##         #
                #                     #
                #    Central pond     #
                #        below        #
                #                     #
                #######################
 
    
# Sequence of antenna changes corresponding to the distances above   
    seq.width  <- c('12', '21', '34', '43')
    seq.length <- c('13', '31', '24', '42')
    seq.diag   <- c('14', '41', '23', '32')
```

---


### 3.2 Function computing the travelled distance per individual

First, I repeated reads at a single antenna, and obtain the antenna changes. For each individual, I reduce the sequence of reads at the different antennas (e.g., 1, 1, 1, 2, 2, 3) in a way that I only keep one read in a repeated sequence (e.g., 1, 2, 3).

Second, I compute the travelled distance between these antennas, at every change, and sum them up.


```{r, message = FALSE}
    trav.dist <- function(new_dataset){
    
    # I split my dataframe into a list of dataframes (one object per individual)
    df_list <- split(new_dataset, f = new_dataset$id)



##  1. REMOVE THE REPEATED READS AND OBTAIN THE ANTENNA CHANGE

    # I define 'df_list_red' which is basically 'df_list' except that the input vector
    # is replaced by the output vector.
    df_list_red <- list()
    nb_ind <- length(df_list)

    
    # I obtain the output vectors and the associated time and Identifier
    for (i in 1:nb_ind) {
      changes          <- which(df_list[[i]]$antenna!= lag(df_list[[i]]$antenna))
      antenna          <- c(df_list[[i]]$antenna[1], df_list[[i]]$antenna[changes])
      time             <- c(df_list[[i]]$time[1], df_list[[i]]$time[changes])
      id               <- c(df_list[[i]]$id[1], df_list[[i]]$id[changes])
      df_list_red[[i]] <- data.frame(antenna, time, id)
    }

    
    # I bind the rows of the list (i.e. make it a dataframe, as it initially was)
    df2 <- bind_rows(df_list_red)
    df2 <- as_tibble(df2)
    # df2 is basically the initial 'new_dataset' but the repeated reads
    # have been eliminated only to keep the first one.

    
    # I obtain the number of times each individual was read in two different antennas consecutively
    Changes <- sapply(df_list_red, nrow)
    id <- numeric() # I obtain the individual names
    for(i in 1:length(df_list_red)){
      id[i] <- df_list_red[[i]][1,3]}

    # I can generate a data frame with number of changes per individual
    df3 <- data.frame(id, Changes)


## 2. DISTANCE TRAVELLED BY EACH INDIVIDUAL

    # A for loop calculating the total distance travelled by each individuals between the antennas it's been read at
    
    # I define my Dist numerical vector
    Dist <- numeric()
    
    for (i in 1:length(df_list_red)){
      # I make three numerical vectors, each for a distance type (i.e. width/length/diagonal)
      # Each element of this vector is the number of times an individual achieved the pattern above
      # E.g. width = c(4, 2, 3, 7) corresponds to an individuals crossing 4 times 11->12, 2 times 12->11,
      # 3 times 13->14 and 7 times 14-13.
      width <- str_count(paste(df_list_red[[i]]$antenna, collapse=""), seq.width)
      length <- str_count(paste(df_list_red[[i]]$antenna, collapse=""), seq.length)
      diagonal <- str_count(paste(df_list_red[[i]]$antenna, collapse=""), seq.diag)

      
      # I obtain the achieved distance per distance type (i.e. width/length/diagonal)
      dist.width <- sum(width)*pond.width
      dist.length <- sum(length)*pond.length
      dist.diagonal <- sum(diagonal)*pond.diagonal
      
      # Total distance
      Dist[i] <- (dist.width + dist.length + dist.diagonal)
    } # end of for loop

    # Total distance travalled by all individuals
    df4 <- cbind(df3, Dist)
    
    return(df4)
    }

```


I run the function and obtain, for every individual, the distance it travelled between all the antennas it's been read at. However, some individuals might not have been read at all. Therefore, I add the individuals that, potentially, haven't been read and indicate their travelled distance as 0.

```{r, message = FALSE}
Travelled.distance <- trav.dist(bottom_clean_df)

   # I check if individuals might have not been recorded at all by the antennas
    non_read_babies <- setdiff(list_fish$id, Travelled.distance$id)
    non_read_babies <- data.frame(id = non_read_babies, Changes =  0, Dist =  0)
    
    # Final df containing the read (and potential non-read) individuals
    Travelled.distance <- rbind(Travelled.distance, non_read_babies)
```




---

### 3.3 Plotting

First, I will, for every individual, indicate to what pond and treatment it is associated with.

```{r, message = FALSE}
    

# I assign every individual to its pond and treatment category
    Travelled.distance <- merge(bottom_variable, Travelled.distance, by = "id", all = T)


```


I first do violin plots (with mean and SD) showing all tratment sequences and the time of the day


```{r, message = FALSE}
  # 2. Violin plots for differences between the 8 ponds within a week
      ggplot(data = Travelled.distance, aes(x = Treatment_seq, y = Dist, fill = time_of_day)) + 
      geom_violin(position = position_dodge(width = 0.4)) + 
      
      geom_boxplot(width=.1, outlier.colour=NA, 
                   position = position_dodge(width = 0.4), colour = "black") +
      
      scale_fill_brewer(palette="Blues") +
      
      stat_summary(fun.data=mean_sdl, 
                   fun.args = list(mult = 1), # I show 1 SD
                   geom = "pointrange", color="#414c61", 
                   position = position_dodge(width = 0.4)) +
      # theme_bw() +
      theme(panel.grid.major.y = element_line(colour = "#d4d4d4"),
            panel.grid.major.x = element_blank(),
            panel.grid.minor = element_line(colour = "#e6e6e6"), 
            axis.ticks.y = element_blank(), 
            axis.ticks.x = element_blank(), 
            panel.background = element_blank(),
            axis.line.y = element_line(color = "black")) +
      labs(y = "Travelled distance (meters)", x =" ") +
      scale_y_continuous(expand = c(0, 0), limits = c(0,NA))


    ggplot(data = Travelled.distance, aes(x = Treatment_seq, y = Dist)) + 
      geom_violin(fill = "#b4d3db") + 
      stat_summary(fun.data=mean_sdl, 
                   fun.args = list(mult = 1), # I show 1 SD
                   geom = "pointrange", color="#414c61", 
                   position = position_dodge(width = 0.4)) +
      # theme_bw() +
      theme(panel.grid.major.y = element_line(colour = "#d4d4d4"),
            panel.grid.major.x = element_blank(),
            panel.grid.minor = element_line(colour = "#e6e6e6"), 
            axis.ticks.y = element_blank(), 
            axis.ticks.x = element_blank(), 
            panel.background = element_blank(),
            axis.line.y = element_line(color = "black")) +
      labs(y = "Travelled distance (meters)", x =" ") +
      scale_y_continuous(expand = c(0, 0), limits = c(0,NA))
```

Below, I will also make a Raincloud plot to see how these scores change over time. No more distinction is made here between the two replicates (morning/afternoon) for visibility reasons.

I first import a few additional packages

```{r, message = FALSE}
    library(caTools)
    library(bitops)
    library(cowplot)
    library(dplyr)
    library(readr)
    library(grid)
```

I change my working directory to have access to the R files from this GitHub repository: https://github.com/RainCloudPlots/RainCloudPlots/tree/master/tutorial_R. 

```{r, message = FALSE}
  # Set working directory
    setwd("/Users/benka/OneDrive/Documents/GitHub/RainCloudPlots/tutorial_R")


    source("R_rainclouds.R")
    source("summarySE.R")
    source("simulateData.R")
```

```{r, message = FALSE}
 
    # This is fake data
    Travelled.distance2 <- rbind(Travelled.distance, Travelled.distance, Travelled.distance)
    Travelled.distance2$Dist <- c(Travelled.distance$Dist, Travelled.distance$Dist/2, Travelled.distance$Dist/3)
    Travelled.distance2$time <- c(rep(c("W1"), times = 100), rep(c("W2"), times = 100), rep(c("W3"), times = 100))
    

    # SUmmary statistics
    sumrepdat <- summarySE(Travelled.distance2, measurevar = "Dist", groupvars=c("Treatment_seq", "time"))    
    
    # General information about the plot
    ggplot(Travelled.distance2, aes(x = time, y = Dist, fill = Treatment_seq)) + 
      
      # Layer 1 - The half-violins to show data point densities
      geom_flat_violin(aes(fill = Treatment_seq), 
                       position = position_nudge(x = .1, y = 0), 
                       adjust = 2, trim = FALSE, alpha = .6, 
                       colour = NA) + 
      
      # Layer 2 - All the individual data points
      geom_point(aes(x = time,
                     group = id,
                     y = Dist, 
                     colour = Treatment_seq), 
                     position = position_dodge(width = .1), 
                     size = 1, shape = 19, alpha = 0.4) + 
      
      # Layer 3 - These individual datapoints are linked together by thin lines
      geom_line(aes(group = id
                ,colour = Treatment_seq
                ), linetype = 1,
                alpha = 0.1, size = 0.5, 
                #colour = "grey",
                position = position_dodge(width = .1)) +


      

      # Layer 5 - A line linking these means
      geom_line(data = sumrepdat, aes(y =  Dist_mean, group = Treatment_seq, 
                                      colour = Treatment_seq), linetype = 1, size = 1) +
      
      # Layer 6 - A mean per treatment sequence
      geom_point(data = sumrepdat, aes(y =  Dist_mean, group = Treatment_seq, 
                                       colour = Treatment_seq), shape = 19, size = 2) +
 
      # Layer 6' - SE/SD bars
      #geom_errorbar(data = sumrepdat, aes( 
      #  y =  Dist_mean, group = Treatment_seq, 
      #  colour = Treatment_seq, ymin =  Dist_mean-sd, 
      #  ymax =  Dist_mean+se), width = 0.05, size = 1.2) +
      
      
      # Define the colours 
      scale_colour_manual(values=c("#eb676e", "#f7bd6a", "#6e67b5", "#b3d6e6")) + 
      scale_fill_manual(values=c("#eb676e", "#f7bd6a", "#6e67b5", "#b3d6e6"))+
      
      # Define the theme
      theme_cowplot()

```

```{r, message = FALSE}

```

```{r, message = FALSE}

```

```{r, message = FALSE}

```

```{r, message = FALSE}

```

```{r, message = FALSE}

```

```{r, message = FALSE}

```

```{r, message = FALSE}

```

