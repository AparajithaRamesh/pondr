---
title: "Behavioural tests"
output: html_notebook
---

This notebook contains chunks computing indiced for a set of behaviours:

- Travelled distance
- Tendency to spend time at the top of the pond
- Latency to cross an exploration box
- Tendency to hide
- Shoaling tendency
There is no behavioural test for the latter behavioural index, but the metric is retrieved from the data of the other tests.

## 1. Packages, data import and basic data manipulation


```{r, results="hide", message = FALSE}
# Packages
  library(dplyr)
  library(tidyr)
  library(tibble)
  library(lubridate)
  library(ggplot2)
  library(readr)
  library(data.table)
  library(patchwork)
  library(stringr)
  library(readxl)
```

I import the four dataset we get every week, one for each behavioural test. I also import the list of all the fishes.

```{r, message = FALSE}

# Data import
df_EB <- read_delim("~/Cours/M2 - Sticklebacks/Data/2. Pre-treatment tests/20201102.CSV", 
      ";", escape_double = FALSE, trim_ws = TRUE)
df_top <- read_delim("20201008.CSV", ";", escape_double = FALSE, trim_ws = TRUE)
df_bottom <- read_delim("~/Cours/M2 - Sticklebacks/Data/1. Preliminary tests/4. Week -1/Oct 27/20201027.CSV", 
                       ";", escape_double = FALSE, trim_ws = TRUE)
df_shelter <- read_delim("20201008.CSV", ";", escape_double = FALSE, trim_ws = TRUE)
list_fish <- read_excel("~/Cours/M2 - Sticklebacks/Data/1. Preliminary tests/4. Week -1/Ben_PITtag_final_grouped_FINAL.xlsx", 
                        sheet = "Sheet1")

```



I create the **clean.data** *function* to clean my data. This function does the following:

- It subsets a few columns of interest from the raw data (i.e. time, antenna, id)
- It keeps only one read per individual and per second for a given antenna (i.e. remove repeats)
- I assign every individual to a category named *time of the day*, indicating if it was tested during the morning or during the afternoon.
- I rename the antenna as *1, 2, 3 and 4* (see Fig 1 & Fig 2).
- I remove the ghost reads, and the reads coming from antenna tests, to only keep the fish reads in the ponds.
- I assign each individual to its *pond number* and *treatment sequence*.

![Figure 1](C:/Users/benka/OneDrive/Documents/Cours/M2 - Sticklebacks/Meetings/Meeting 7 - Last practical details/Practicalities/Slide8.png)

![Figure 2](C:/Users/benka/OneDrive/Documents/Cours/M2 - Sticklebacks/Meetings/Meeting 7 - Last practical details/Practicalities/Slide9.png)

```{r, message = FALSE}
clean.data <- function(df){

# Naming my columns
  names(df) <- c( "Identifier", "Date", "Time",
                  "Unit.number", "Antenna.number", "Transponder.type",
                  "Transponder.code", "Weight", "Input.status",
                  "Output.status", "Event", "GPS.coordinates")


# Defining my variables
  df$Identifier <- as.integer(df$Identifier)
  df$Time <- as.character(df$Time)
  df$Unit.number <- as.integer(df$Unit.number)
  df$Transponder.code <- as.character(df$Transponder.code)
  df$Actual_time <- dmy_hms(paste(df$Date,df$Time,sep=" "))

  
  
# I make a new df with a subset of the variables of interest here
  new_dataset<-subset(df, select=c(Actual_time, Unit.number, Transponder.code))
  names(new_dataset) <- c("time", "antenna", "id")
  new_dataset <- new_dataset  %>% distinct()
 
  
   
# I assign every individual to a group (Morning/Afternoon)
  x = as.POSIXct(strptime(c("090000","123000","190000"),"%H%M%S"),"UTC")
  date(x) <- new_dataset$time[1]

  new_dataset$time_of_day <- case_when(
    between(new_dataset$time,x[1],x[2]) ~"Morning",
    between(new_dataset$time,x[2],x[3]) ~"Afternoon")
  
  
  
# I rename my antennas with a standardised notation across ponds (see scheme above)
    new_dataset[new_dataset == 11 | new_dataset == 21 | new_dataset == 31 | new_dataset == 41] <- 1
    new_dataset[new_dataset == 12 | new_dataset == 22 | new_dataset == 32 | new_dataset == 42] <- 2
    new_dataset[new_dataset == 13 | new_dataset == 23 | new_dataset == 33 | new_dataset == 43] <- 3
    new_dataset[new_dataset == 14 | new_dataset == 24 | new_dataset == 35 | new_dataset == 34 | 
                new_dataset == 44] <- 4
    

  # Now, I will remove all the reads that do not come from the fish present in the ponds (e.g. ghost reads, test reads)
    list_fish <- read_excel("~/Cours/M2 - Sticklebacks/Data/1. Preliminary tests/4. Week -1/Ben_PITtag_final_grouped_FINAL.xlsx", 
                            sheet = "Sheet1")

# I identify the reads that do not  come from the ponds
    ghost_reads <- setdiff(new_dataset$id, list_fish$id)

# I remove all of them from the dataframe
    for (i in 1:length(ghost_reads)){
    new_dataset <- new_dataset[!(new_dataset$id == ghost_reads[i]),]
    }
    
# Now, if I run this line, I should obtain a value equal or smaller than 200.
    length(unique(new_dataset$id))    
    
# I assign every individual to its pond and treatment category
    new_dataset <- merge(new_dataset, list_fish[c(2,8,9)], by = "id")
    
  
  
  return(new_dataset)
  }

```

---

## 2. Latency to explore the box
### 2.1 Data manipulation and object definition

I first run the **clean.data** function on the EB data frame. 

```{r, message = FALSE}
EB_clean_df <- clean.data(df_EB)

```

I then define the crossing sequences and starting times.

```{r, message = FALSE}
# I indicate the crossing sequences (a -> d and d -> a)
  p1.4 = c(1, 2, 3, 4)
  p4.1 = c(4, 3, 2, 1)

# I define my starting times
  start_morning = as.POSIXct(strptime(c("090000"),"%H%M%S"),"UTC")
  date(start_morning) <- EB_clean_df$time[1]
  
  start_afternoon = as.POSIXct(strptime(c("123000"),"%H%M%S"),"UTC")
  date(start_afternoon) <- EB_clean_df$time[1]
```


I then write my function


```{r, message = FALSE}
  
# 1. I create the 'lat.expl' function for 'Latency to explore'.
    # From the cleaned data frame, it outputs all the individual full crossings.
    lat.expl <- function(df, pattern1, pattern2, initial_time){
    
    
  # I split my dataframe into a list of dataframes (one object per individual)
   df_list <- split(df, f = df$id)


  ## 1. REMOVE THE REPEATED READS
  # For each individual, I reduce the input vector (e.g., 1, 1, 1, 2, 2, 3) in a
  # way that one read is kept per sequence of identical numbers (e.g., 1, 2, 3).

  # I define 'df_list_red' which is basically 'df_list' except that the input vector
  # is replaced by the output vector.
    df_list_red <- list()
    nb_ind <- length(df_list)

  # I obtain the output vectors and the associated time and Identifier
    for (i in 1:nb_ind) {
      df_list[[i]] <- df_list[[i]][order(as.POSIXct(df_list[[i]]$time)),]
      changes          <- which(df_list[[i]]$antenna!= lag(df_list[[i]]$antenna))
      antenna          <- c(df_list[[i]]$antenna[1], df_list[[i]]$antenna[changes])
      time             <- c(df_list[[i]]$time[1], df_list[[i]]$time[changes])
      id               <- c(df_list[[i]]$id[1], df_list[[i]]$id[changes])
      df_list_red[[i]] <- data.frame(antenna, time, id)
    }


  # I bind the rows of the list (i.e. make it a dataframe, as it initially was)
    df2 <- bind_rows(df_list_red)
    df2 <- as_tibble(df2)
    length(unique(df2$id))
    
  # df2 is basically the initial 'df' but the repeated reads
  # have been eliminated only to keep the first one.


  ## 2. IDENTIFY WHEN INDIVIDUALS CROSS THE BOX ENTIRELY
  # I stole the next piece of code from someone way smarter than me (see R Stack Overflow 41130912).
  # First, I keep reads when individuals go through the box the following way: 1 -> 2 -> 3 -> 4
    len_pattern = 4
    df_abcd <- df2 %>% arrange(id, time) %>% group_by(id) %>%
    # check multiple lags condition
    mutate(ab = Reduce("&", Map("==", shift(antenna, n = 0:(len_pattern - 1), type = "lead"), pattern1)),
    g = cumsum(ab)) %>%
    # use reduce or to subset sequence rows having the same length as the pattern
    filter(Reduce("|", shift(ab, n = 0:(len_pattern - 1), type = "lag"))) %>%
    # make unique names
    group_by(g, add = TRUE) %>% mutate(antenna = paste(antenna, 1:n(), sep = "_")) %>%
    # pivoting the table to wide format
    select(-ab) %>% spread(antenna, time)


  # Second, I keep reads when individuals go through the box the other way around: 4 -> 3 -> 2 -> 1
    df_dcba <- df2 %>% arrange(id, time) %>% group_by(id) %>%
    # check multiple lags condition
    mutate(ab = Reduce("&", Map("==", shift(antenna, n = 0:(len_pattern - 1), type = "lead"), pattern2)),
    g = cumsum(ab)) %>%
    # use reduce or to subset sequence rows having the same length as the pattern
    filter(Reduce("|", shift(ab, n = 0:(len_pattern - 1), type = "lag"))) %>%
    # make unique names
    group_by(g, add = TRUE) %>% mutate(antenna = paste(antenna, 1:n(), sep = "_")) %>%
    # pivoting the table to wide format
    select(-ab) %>% spread(antenna, time)


  # I rename the columns of the two dataframes I created
  names(df_abcd) <- c("id", "g", "Ant1", "Ant2", "Ant3", "Ant4")
  names(df_dcba) <- c("id", "g", "Ant1", "Ant2", "Ant3", "Ant4")

  # I obtain a dataframe in which each row represents one individual full crossing
  df3 <- rbind(df_abcd, df_dcba)

  # I keep individuals with the smallest 'arrival' (i.e. Ant2) value.
  df3 <- df3 %>%
    group_by(id) %>%
    slice(which.min(Ant2))




  ## 3. CALCULATE LATENCY TIME
  # I add a new column with the time to cross the box since the start of the test
  df3 <- mutate(df3, time_since_start = difftime(Ant2, initial_time, units='mins'))
  df3$time_since_start <- as.numeric(df3$time_since_start)




  return(df3)
}

```


I run my function.

```{r}
# I run my functions for the morning and the afternoon
  final_df_morning <- lat.expl(subset(EB_clean_df, time_of_day == "Morning"), p1.4, p4.1, start_morning)
  final_df_afternoon <- lat.expl(subset(EB_clean_df, time_of_day == "Afternoon"), p1.4, p4.1, start_afternoon)

# I obtain my final dataset with the first crossing sequence for every individual and at what time it happened
  final_df <- rbind(final_df_morning, final_df_afternoon)

  final_df <- merge(unique(EB_clean_df[c(1, 4, 5, 6)]), final_df, by = "id", all = F)
```


```{r, message = FALSE}
  ggplot(data=final_df, aes(time_since_start)) +
    geom_histogram(aes(),
                   bins = 6,
                   fill="#6f7b96",
                   colour = "white") +
    labs(x="Latency to explore the box (minutes)", y="Count") +
    theme(axis.ticks.x = element_blank(),
          panel.background = element_rect(fill = "#f7f5f5"))
```



```{r, message = FALSE}

    ggplot(data = final_df, aes(x = Treatment_seq, y = time_since_start, fill = time_of_day)) + 
      geom_violin(position = position_dodge(width = 0.4)) + 
      #geom_boxplot(width=.1, outlier.colour=NA, position = position_dodge(width = 0.4), colour = "black") +
      scale_fill_brewer(palette="Blues") +
      stat_summary(fun.data=mean_sdl, 
                   fun.args = list(mult = 1), # I show 1 SD
                   geom = "pointrange", color="#414c61", 
                   position = position_dodge(width = 0.4)) +
      # theme_bw() +
      theme(panel.grid.major.y = element_line(colour = "#d4d4d4"),
            panel.grid.major.x = element_blank(),
            panel.grid.minor = element_line(colour = "#e6e6e6"), 
            axis.ticks.y = element_blank(), 
            axis.ticks.x = element_blank(), 
            panel.background = element_blank(),
            axis.line.y = element_line(color = "black")) +
      labs(y = "Latency to explore", x =" ") +
      scale_y_continuous(expand = c(0, 0), limits = c(0,NA))



    ggplot(data = final_df, aes(x = Treatment_seq, y = time_since_start)) + 
      geom_violin(fill = "#b4d3db") + 
      stat_summary(fun.data=mean_sdl, 
                   fun.args = list(mult = 1), # I show 1 SD
                   geom = "pointrange", color="#414c61", 
                   position = position_dodge(width = 0.4)) +
      # theme_bw() +
      theme(panel.grid.major.y = element_line(colour = "#d4d4d4"),
            panel.grid.major.x = element_blank(),
            panel.grid.minor = element_line(colour = "#e6e6e6"), 
            axis.ticks.y = element_blank(), 
            axis.ticks.x = element_blank(), 
            panel.background = element_blank(),
            axis.line.y = element_line(color = "black")) +
      labs(y = "Latency to explore", x =" ") +
      scale_y_continuous(expand = c(0, 0), limits = c(0,NA))
```


Here is an alternative version of the chunk above. It is less elegant, yet (a lot?) more understandible.

```{r, message = FALSE}

# Packages
  library(micropan)

# Input data examples
#df <- subset(df2, id == "0007A03565") # No complete crosses
#df <- subset(df2, id == "0007A678A5") # Complete crosses
#df <- df3[[35]]


# Function
# Input = Dataframe containing the antenna changes for one individual
# Output = The first full cross of the exploration box, or an empty dataframe if
# the individual hasn't fully crossed the box.
first.cross <- function(df){
  
  # I identify all the row numbers at which the individual started the sequential
  # crossing between antenna 1 and antenna 4
  rowstarts_1234  <- unlist(gregexpr("1234", paste(df$antenna, collapse="")))
  
  # If the individual has crossed the box from antenna 1 to antenna 4.
  if (rowstarts_1234[1] != -1){
  
  # Then, I subset the first full box cross (1,2,3,4)
    first_cross_1234 <- df[sort(c(outer(rowstarts_1234[1], (0:3), "+"))), ]
    first_cross_1234 <- first_cross_1234 %>% spread(antenna,time)
    first_cross_1234 <- as.data.frame(first_cross_1234)
    names(first_cross_1234) <- c("id", "Ant1", "Ant2", "Ant3", "Ant4")}
  
  # On the other hand, if the individual has crossed the box from antenna 1 to antenna 4.
  if (rowstarts_1234[1] == -1){first_cross_1234 <- 
  # Then I just obtain an empty tibble.  
    first_cross_4321 <- 
    tibble( )}
 
  # Same as above but between antenna 4 and antenna 1. 
    rowstarts_4321  <- unlist(gregexpr("4321", paste(df$antenna, collapse="")))
  if (rowstarts_4321[1] != -1){
  first_cross_4321 <- df[sort(c(outer(rowstarts_4321[1], (0:3), "+"))), ]
  first_cross_4321 <- first_cross_4321 %>% spread(antenna,time)
  first_cross_4321 <- first_cross_4321[c(1,5,4,3,2)]
  first_cross_4321 <- as.data.frame(first_cross_4321)
  names(first_cross_4321) <- c("id", "Ant1", "Ant2", "Ant3", "Ant4")}
  if (rowstarts_4321[1] == -1){first_cross_4321 <- 
    tibble( )}
  
  # I rbind my two tibbles.
  first_cross <- rbind(first_cross_1234, first_cross_4321)
  
  
  # If the individual did at least one full cross...
  if(dim(first_cross)[1] != 0){
  # Then, I subset its first full cross.
    first_cross <- first_cross[order(first_cross$Ant2),]
    first_cross <- first_cross[1,]}
  
  # On the other hand, if the individual hasn't fully crossed the box...
  if(dim(first_cross)[1] == 0){
  # Then, I just obtain a data frame with NAs.
      first_cross <- data.frame(id = df$id[1], Ant1 = NA,
                   Ant2 = NA, Ant3 = NA, Ant4 = NA)}
  
    
  return(first_cross)} # end of the function


# This part below still has to be written properly.

df3 <- split(df2, f = df2$id)

first_crosses <- list()
for(i in 1:length(df3)){
  
  first_crosses[[i]] <- first.cross(df3[[i]])
}
df4 <- bind_rows(first_crosses)

subset(df4, id == "0007A04979")


# I add a new column with the time to cross the box since the start of the test
df3 <- mutate(df3, time_since_start = difftime(Ant2, initial_time, units='m'))
df3$time_since_start <- as.numeric(df3$time_since_start)

```



```{r, message = FALSE}

```

```{r, message = FALSE}

```



## 3. Travelled distance
### 3.1 Data manipulation and object definition


I first run the **clean.data** function on the bottom antenna data frame. 

```{r, message = FALSE}
bottom_clean_df <- clean.data(df_bottom)

```

Then, I split it based on (i) antenna and (ii) individuals, as two list of data frames.

```{r, message = FALSE}
# I split my dataframe into a list of dataframes (one object per individual)
    bottom_list_df_ind <- split(bottom_clean_df, f = bottom_clean_df$id)

# I split my dataframe into a list of dataframes (one object per individual)
    bottom_list_df_ant <- split(bottom_clean_df, f = bottom_clean_df$antenna)
```


I define the distances between the different antennas, and the sequence of crossing corresponding to these distances.

```{r, message = FALSE}
    # Distances between antennas
    pond.width   <- 1
    pond.length  <- 1.1
    pond.diagonal<- 1.25


    
                #######################
                #                     # 
                #        #   #        #
                #     #        #      #
                #   #  3      4   #   #
                #   #             #   #
                #   #             #   #
                #   #             #   #
                #   #  2      1   #   #
                #     #        #      #
                #       ## ##         #
                #                     #
                #    Central pond     #
                #        below        #
                #                     #
                #######################
 
    
# Sequence of antenna changes corresponding to the distances above   
    seq.width  <- c('12', '21', '34', '43')
    seq.length <- c('13', '31', '24', '42')
    seq.diag   <- c('14', '41', '23', '32')
```

---


### 3.2 Function computing the travelled distance per individual

First, I repeated reads at a single antenna, and obtain the antenna changes. For each individual, I reduce the sequence of reads at the different antennas (e.g., 1, 1, 1, 2, 2, 3) in a way that I only keep one read in a repeated sequence (e.g., 1, 2, 3).

Second, I compute the travelled distance between these antennas, at every change, and sum them up.


```{r, message = FALSE}
    trav.dist <- function(new_dataset){
    
    # I split my dataframe into a list of dataframes (one object per individual)
    df_list <- split(new_dataset, f = new_dataset$id)



##  1. REMOVE THE REPEATED READS AND OBTAIN THE ANTENNA CHANGE

    # I define 'df_list_red' which is basically 'df_list' except that the input vector
    # is replaced by the output vector.
    df_list_red <- list()
    nb_ind <- length(df_list)

    # I obtain the output vectors and the associated time and Identifier
    for (i in 1:nb_ind) {
      changes          <- which(df_list[[i]]$antenna!= lag(df_list[[i]]$antenna))
      antenna          <- c(df_list[[i]]$antenna[1], df_list[[i]]$antenna[changes])
      time             <- c(df_list[[i]]$time[1], df_list[[i]]$time[changes])
      id               <- c(df_list[[i]]$id[1], df_list[[i]]$id[changes])
      df_list_red[[i]] <- data.frame(antenna, time, id)
    }

    # I bind the rows of the list (i.e. make it a dataframe, as it initially was)
    df2 <- bind_rows(df_list_red)
    df2 <- as_tibble(df2)
    # df2 is basically the initial 'new_dataset' but the repeated reads
    # have been eliminated only to keep the first one.

    # I obtain the number of times each individual was read in two different antennas consecutively
    Changes <- sapply(df_list_red, nrow)
    id <- numeric() # I obtain the individual names
    for(i in 1:length(df_list_red)){
      id[i] <- df_list_red[[i]][1,3]}

    # I can generate a data frame with number of changes per individual
    df3 <- data.frame(id, Changes)


## 2. DISTANCE TRAVELLED BY EACH INDIVIDUAL

    # A for loop calculating the total distance travelled by each individuals between the antennas it's been read at
    
    # I define my Dist numerical vector
    Dist <- numeric()
    
    for (i in 1:length(df_list_red)){
      # I make three numerical vectors, each for a distance type (i.e. width/length/diagonal)
      # Each element of this vector is the number of times an individual achieved the pattern above
      # E.g. width = c(4, 2, 3, 7) corresponds to an individuals crossing 4 times 11->12, 2 times 12->11,
      # 3 times 13->14 and 7 times 14-13.
      width <- str_count(paste(df_list_red[[i]]$antenna, collapse=""), seq.width)
      length <- str_count(paste(df_list_red[[i]]$antenna, collapse=""), seq.length)
      diagonal <- str_count(paste(df_list_red[[i]]$antenna, collapse=""), seq.diag)

      # I obtain the achieved distance per distance type (i.e. width/length/diagonal)
      dist.width <- sum(width)*pond.width
      dist.length <- sum(length)*pond.length
      dist.diagonal <- sum(diagonal)*pond.diagonal
      # Total distance
      Dist[i] <- (dist.width + dist.length + dist.diagonal)
    }

    # Total distance travalled by all individuals
    df4 <- cbind(df3, Dist)
    
    return(df4)
    }

```


I run the function and obtain, for every individual, the distance it travelled between all the antennas it's been read at. However, some individuals might not have been read at all. Therefore, I add the individuals that, potentially, haven't been read and indicate their travelled distance as 0.

```{r, message = FALSE}
Travelled.distance <- trav.dist(bottom_clean_df)

   # I check if individuals might have not been recorded at all by the antennas
    non_read_babies <- setdiff(list_fish$id, Travelled.distance$id)
    non_read_babies <- data.frame(id = non_read_babies, Changes =  0, Dist =  0)
    
    # Final df containing the read (and potential non-read) individuals
    Travelled.distance <- rbind(Travelled.distance, non_read_babies)
```




---

First, I will, for every individual, indicate to what pond and treatment it is associated with.

```{r, message = FALSE}
    

# I assign every individual to its pond and treatment category
    Travelled.distance <- merge(unique(bottom_clean_df[c(1, 4, 5, 6)]), Travelled.distance, by = "id", all = F)


```


### 3.3 Plotting

I first do violin plots (with mean and SD) showing all tratment sequences and the time of the day


```{r, message = FALSE}
  # 2. Violin plots for differences between the 8 ponds within a week
    ggplot(data = Travelled.distance, aes(x = Treatment_seq, y = Dist, fill = time_of_day)) + 
      geom_violin(position = position_dodge(width = 0.4)) + 
      #geom_boxplot(width=.1, outlier.colour=NA, position = position_dodge(width = 0.4), colour = "black") +
      scale_fill_brewer(palette="Blues") +
      stat_summary(fun.data=mean_sdl, 
                   fun.args = list(mult = 1), # I show 1 SD
                   geom = "pointrange", color="#414c61", 
                   position = position_dodge(width = 0.4)) +
      # theme_bw() +
      theme(panel.grid.major.y = element_line(colour = "#d4d4d4"),
            panel.grid.major.x = element_blank(),
            panel.grid.minor = element_line(colour = "#e6e6e6"), 
            axis.ticks.y = element_blank(), 
            axis.ticks.x = element_blank(), 
            panel.background = element_blank(),
            axis.line.y = element_line(color = "black")) +
      labs(y = "Distance", x =" ") +
      scale_y_continuous(expand = c(0, 0), limits = c(0,NA))
```

Below, I will also make a Raincloud plot to see how these scores change over time. No more distinction is made here between the two replicates (morning/afternoon) for visibility reasons.

I first import a few additional packages

```{r, message = FALSE}
    library(caTools)
    library(bitops)
    library(cowplot)
    library(dplyr)
    library(readr)
    library(grid)
```

I change my working directory to have access to the R files from this GitHub repository: https://github.com/RainCloudPlots/RainCloudPlots/tree/master/tutorial_R. 

```{r, message = FALSE}
  # Set working directory
    setwd("/Users/benka/OneDrive/Documents/GitHub/RainCloudPlots/tutorial_R")


    source("R_rainclouds.R")
    source("summarySE.R")
    source("simulateData.R")
```

```{r, message = FALSE}
 
    # This is fake data
    Travelled.distance2 <- rbind(Travelled.distance, Travelled.distance, Travelled.distance)
    Travelled.distance2$Dist <- c(Travelled.distance$Dist, Travelled.distance$Dist/2, Travelled.distance$Dist/3)
    Travelled.distance2$time <- c(rep(c("W1"), times = 100), rep(c("W2"), times = 100), rep(c("W3"), times = 100))
    

    # SUmmary statistics
    sumrepdat <- summarySE(Travelled.distance2, measurevar = "Dist", groupvars=c("Treatment_seq", "time"))    
    
    # General information about the plot
    ggplot(Travelled.distance2, aes(x = time, y = Dist, fill = Treatment_seq)) + 
      
      # Layer 1 - The half-violins to show data point densities
      geom_flat_violin(aes(fill = Treatment_seq), 
                       position = position_nudge(x = .1, y = 0), 
                       adjust = 2, trim = FALSE, alpha = .6, 
                       colour = NA) + 
      
      # Layer 2 - All the individual data points
      geom_point(aes(x = time,
                     group = id,
                     y = Dist, 
                     colour = Treatment_seq), 
                     position = position_dodge(width = .1), 
                     size = 1, shape = 19, alpha = 0.4) + 
      
      # Layer 3 - These individual datapoints are linked together by thin lines
      geom_line(aes(group = id
                ,colour = Treatment_seq
                ), linetype = 1,
                alpha = 0.1, size = 0.5, 
                #colour = "grey",
                position = position_dodge(width = .1)) +


      

      # Layer 5 - A line linking these means
      geom_line(data = sumrepdat, aes(y =  Dist_mean, group = Treatment_seq, 
                                      colour = Treatment_seq), linetype = 1, size = 1) +
      
      # Layer 6 - A mean per treatment sequence
      geom_point(data = sumrepdat, aes(y =  Dist_mean, group = Treatment_seq, 
                                       colour = Treatment_seq), shape = 19, size = 2) +
 
      # Layer 6' - SE/SD bars
      #geom_errorbar(data = sumrepdat, aes( 
      #  y =  Dist_mean, group = Treatment_seq, 
      #  colour = Treatment_seq, ymin =  Dist_mean-sd, 
      #  ymax =  Dist_mean+se), width = 0.05, size = 1.2) +
      
      
      # Define the colours 
      scale_colour_manual(values=c("#eb676e", "#f7bd6a", "#6e67b5", "#b3d6e6")) + 
      scale_fill_manual(values=c("#eb676e", "#f7bd6a", "#6e67b5", "#b3d6e6"))+
      
      # Define the theme
      theme_cowplot()

```

```{r, message = FALSE}

```

```{r, message = FALSE}

```

```{r, message = FALSE}

```

```{r, message = FALSE}

```

```{r, message = FALSE}

```

```{r, message = FALSE}

```

```{r, message = FALSE}

```

