---
title: "Exploration box fancy function"
output: html_notebook
---



The chunk below aims at, from one day of EB data, obtain, for each fish, three different metrics for exploration tendency. The function is built the following way:

- I define a few objects and start a loop going through all individuals

- **Index 1** - Latency to enter the box. I simply obtain, for each individual, the first read at antenna 2 or 3.


- I obtain the antenna changes. If an individual has been read at the antenna the following way (1, 1, 1, 2, 2, 3), I only keep the first reads for each sequence of identical numbers. The output is, for the example above: 1, 2, 3. 


- I split these antenna change reads as a list of data frames. Every time that an individual is read at antenna 1 or 4 (entrances of the box), I split the data frame. I know that if, after a 1 or a 4, there is a 2 or a 3, the individual entered the box. I can then trace the individual until it leaves the box again (ant 1 or 4). This perspective is used for calculating index 2.

- Compute **Index 2** - First time that an individual fully crosses the box. To do so, I am interested in the first sequence containing at least a read from antenna 2 *and* a read from antenna 3, before the fish leaves the box, either via antenna 1 or via antenna 4. The sequences could be, for instance, (1,2,3,4) or (4,3,2,1) or (1,2,3,2,1) or (1,2,3,2,3,2,3,4) etc. It needs to start by a 1 or a 4, to end by a 1 or a for, and to have at least one 2 and one 3 in between.


- Compute **Index 3** - Time spent in the box. In this case, the individual does not need to fully cross the box (i.e. no need to be read by antenna 2 *and* 3 after entering the box and before leaving the box). Instead, I simply calculate the time between an individual is read at antenna 2 or 3 until it is read at antenna 1 or 4 again, whatever the sequence is. The sequence could simply be 4 (enter the box) - 3 (in the box) - 4 (leaves the box), and I would look at the time between 3 and 4. Then, I sum all the times corresponding to the different sequences.


```{r}

## 1. DEFINE OBJECTS
  # I split my dataframe into a list of dataframes (one object per individual)
    EB_list_df_id <- split(EB_clean_df, f = EB_clean_df$id)
    EB_list_changes <- list()
    index1 <- list()
    index2 <- list()
    index3 <- list()
  
    
    
  # For every individual...
  for (i in 1:length(EB_list_df_id)){
    
## 2. INDEX 1 - FIRST TIME ENTERING THE BOX
  index1[[i]] <- subset(EB_list_df_id[[i]], antenna == 2 | antenna == 3)[1,]
  
    
  
    

## 3. ANTENNA CHANGES
  # I obtain the reads corresponding to an antenna change and the
  # corresponding antenna number, time and fish id.
  EB_list_df_id[[i]][order(as.POSIXct(EB_list_df_id[[i]]$time)),]
  
  changes          <- which(EB_list_df_id[[i]]$antenna!= lag(EB_list_df_id[[i]]$antenna))
  antenna          <- c(EB_list_df_id[[i]]$antenna[1], EB_list_df_id[[i]]$antenna[changes])
  time             <- c(EB_list_df_id[[i]]$time[1], EB_list_df_id[[i]]$time[changes])
  id               <- c(EB_list_df_id[[i]]$id[1], EB_list_df_id[[i]]$id[changes])
  EB_list_changes[[i]] <- data.frame(antenna, time, id)
  




## 4. SPLIT THESE ANTENNA CHANGES DF WHEN THE FISH IS READ AT ANT 1 OR 4
  # I mark all the row numbers at which the fish was read at antenna 1 or a 4
  vec <- which(EB_list_changes[[i]][,"antenna"] == 1 | EB_list_changes[[i]][,"antenna"] == 4)
  
  # I want to cut *after* reads at antenna 1 and 4
  vec <- vec  +1
  
  # I split my data frame every time the individual passes by ant 1 or 4
  list <- split(EB_list_changes[[i]], cumsum(1:nrow(EB_list_changes[[i]]) %in% vec))

  
  
  
  
## 5. INDEX 2 - FIRST TIME TO FULLY CROSS THE BOX
  # I select the sequences for which the individual is read at antennas 2 *and* 3
  cond1 <- lapply(list, function(x) nrow(x) >= 3)

  # I apply this condition to keep the crossing sequences
  list1 <- list[unlist(cond1)]

  # If there is such a sequence corresponding to a full crossing
  if (length(list1) != 0){

  # Then I subset the first after being read at 1 or 3 (necessarily at antenna 2 or 3)
  index2[[i]] <- subset(list1[[1]], time == list1[[1]]$time[1])

  # Eventually, this list contains, for each individual that fully crossed the box,
  # its first read at antenna 2 or 3 after entering the box for a full cross.

  } # end of if

  
  
  
  

## 6. INDEX 3 - DURATION SPENT IN THE BOX
  # I select the sequences for which the individual is read at least once at antenna 2 or 3
  cond2 <- lapply(list, function(x) nrow(x) >= 2)
  
  # I keep the sequences corresponding to this condition
  list2 <- list[unlist(cond2)]

  # If the individual entered the box at least once
  if (length(list2) != 0){

  # For each sequence
  for(x in 1:length(list2)){
    
  # I set my initial value of a as 0
  duration <- 0
  
  # And sum all the time spent inside the box
  duration <- duration + difftime(list2[[x]][nrow(list2[[x]]), ]$time, list2[[x]][1,]$time, units='m')

  # I keep this duration and indicate the name of the corresponding individual
  index3[[i]] <- data.frame(id = list2[[1]]$id[1], duration)

  } # end of index 3 sequences for loop
  } # end of if

} # end of main for loop (going through individuals)


# I bind the rows of my list.
index1 <- bind_rows(index1)
index1 <- na.omit(index1)
names(index1)[2] <- "time_entering"


index2 <- bind_rows(index2)
names(index2)[2] <- "time_first_cross"



index3 <- bind_rows(index3)
index3$duration <- as.numeric(index3$duration)

indices <- merge(index1[c("id", "time_entering")], index2[c("id", "time_first_cross")], by = "id", all = T)
indices <- merge(indices, index3, by ="id", all = T)
indices <- merge(indices, EB_variables, by = "id", all = T)

    
  indices_morning <- subset(indices, time_of_day == "Morning") %>%
    mutate(latency_enter = as.numeric(difftime(time_entering, start_morning, units='m')),
           latency_cross = as.numeric(difftime(time_first_cross, start_morning, units='m'))
           )

  indices_afternoon <- subset(indices, time_of_day == "Afternoon") %>%
    mutate(latency_enter = as.numeric(difftime(time_entering, start_afternoon, units='m')),
           latency_cross = as.numeric(difftime(time_first_cross, start_afternoon, units='m'))
           )

  indices <- rbind(indices_morning, indices_afternoon)

  indices <- indices %>%
    mutate(latency_enter = if_else(is.na(latency_enter), 150, latency_enter),
           latency_cross = if_else(is.na(latency_cross), 150, latency_cross),
           duration = if_else(is.na(duration), 0, duration))

```
