---
title: "StalkeR package workflow"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{StalkeR package workflow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

This package aims at providing a efficient workflow for extracting, formatting and analyzing data from PIT / RFID readers in the context of studying animal behavior using an experimental approach. A schematic version of this vignette is available in the *StalkeR cheat sheet*. This package contains functions enabling to obtain, *e.g.* for each individual, a sociability index, the distance travelled between several antennas, or the latency to reach a certain antenna.

First, you can (install and) load the *StalkeR* package.

```{r setup}

library(pondr)

```

------------------------------------------------------------------------

# Format data

## What is an experimental block?

Before starting to use the *StalkeR* package functions, you have to format and organize your data in a certain way. The unit of the *StalkeR* package is a data frame containing *reads* for one *experimental block*. This means that in the data frame, every row is one read, containing information about the individual id, the antenna and the exact time of the read. An *experimental block* represents a unit limited in *space* and *time*, with associated antennas. For instance, if you work with birds, an experimental block can be one enclosure with several animals. If you work with fishes, an experimental block might be a pond/aquarium containing a group of fishes. What *an* experimental block is not:

-   An enclosures in which a series of birds (*e.g.*, ID_1, ID_2 and ID_3) have been tested using the antennas A1, A2, and A3 during one day, and in which another set of birds (*e.g.* ID_4, ID_5, ID_6) have been tested using the antennas A4, A5, A6 the next day. In this case, day 1 represents one experimental block, and day 2 represents a second one.
-   Two aquariums in which antennas are installed during the same day. The individuals of aquarium 1 (*e.g.*, ID_A, ID_B and ID_C) can only be read by antennas A1, A2 and A3, the individuals of aquarium 2 (*e.g.* ID_D, ID_E, ID_F) can only be read by the antennas A4, A5, A6.In this case, each aquarium is an experimental block.

To obtain reads from one experimental block, we suggest to use the following workflow.

## Building a reference list per experimental block (`block_ref_df`)

First, you should build the `block_ref_df` data frame. This object contains a list of all the individuals of one experimental block. In addition, several covariates can be added to the data frame, *e.g.* sex, size or experimental treatment. The data frame *must* contain at least the *id* columns with the individuals identification code/number.

```{r}

# I import the example data frame
data(block_ref_df)

# I show the first rows of this example
head(block_ref_df)
```

## Building the `raw_df` object

Then, there are two options: (i) the data frame(s) you obtain from your PIT / RFID readers contain reads already corresponding to experimental blocks (one data frame per experimental block); (ii) the data frame(s) you obtain from your PIT / RFID readers contain reads from several experimental blocks (one data frame for several experimental block).

If you are in the first case, you can move to the 'Format `raw_df`' section below. If you are in the second case, you need to subset the reads corresponding to your different experimental blocks. To do so, we suggest to use the `inner_join` function of the *dyplyr* package, or the `merge` function of *base* R, for example.

### Format `raw_df`

You must be now working with a data frame containing reads from one experimental block. This data frame must contain at least four different columns: *id*, *date*, *time* and *antenna*. The *id* column must contain a unique number/code per individual; the *date* column must contain the data at the dd-mm-yy format;the *time* column must contain the time in the hh:mm:ss format; the *column* must contain a unique antenna number/code. Be sure to name these columns as in the example below, keeping in mind that R is case sensitive (no capital letters in columns name).

```{r}
# I import the example data frame
data(raw_df)

# I show the first rows of this example
head(raw_df)
```

Now that `block_ref_df` and `raw_df` are ready, you can start to use the different package functions.

------------------------------------------------------------------------

# Clean the data

The first function has to be used before using any of the next *StalkeR* functions. It uses the `block_ref_df` and `raw_df` objects as inputs, and outputs a cleaner version of `raw_df` named `block_df`. The function does the following actions:

-   It keeps the columns of interest (*i.e.* id, antenna and time).
-   The time format is changed to *Posixt* format.
-   It keep one read per individual at a certain antenna per second (*i.e.* remove repeats).
-   It remove ghost reads test reads, or any read that do not correspond to individuals present in the `block_ref_df` object.
-   It orders the data frame based on time.

The output, `block_df`, is the working unit of this package.

![The `pr_clean_data` function.](pr_clean_data.png){width="50%"}
